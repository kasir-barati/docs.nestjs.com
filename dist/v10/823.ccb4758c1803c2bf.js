"use strict";(self.webpackChunkdocs_nestjs_com=self.webpackChunkdocs_nestjs_com||[]).push([[823],{4823:(O,y,c)=>{c.r(y),c.d(y,{FundamentalsModule:()=>q});var w=c(177),p=c(2647),C=c(3887),F=c(8050),e=c(4438),l=c(4819);let x=(()=>{class t extends F.y{static \u0275fac=(()=>{let o;return function(n){return(o||(o=e.xGo(t)))(n||t)}})();static \u0275cmp=e.VBU({type:t,selectors:[["app-async-components"]],features:[e.Vt3],decls:51,vars:0,consts:[["contentReference",""],[1,"content"],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/async-components.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","asynchronous-providers"],[1,"language-typescript"],[1,"info"],["routerLink","/fundamentals/custom-providers"],["appAnchor","","id","injection"],["appAnchor","","id","example"],["routerLink","/recipes/sql-typeorm"]],template:function(s,n){1&s&&(e.j41(0,"div",1,0)(2,"div",2)(3,"a",3),e.nrm(4,"i",4),e.k0s()(),e.j41(5,"h3",5),e.EFF(6,"Asynchronous providers"),e.k0s(),e.j41(7,"p"),e.EFF(8,"At times, the application start should be delayed until one or more "),e.j41(9,"strong"),e.EFF(10,"asynchronous tasks"),e.k0s(),e.EFF(11," are completed. For example, you may not want to start accepting requests until the connection with the database has been established. You can achieve this using asynchronous providers."),e.k0s(),e.j41(12,"p"),e.EFF(13,"The syntax for this is to use "),e.j41(14,"code"),e.EFF(15,"async/await"),e.k0s(),e.EFF(16," with the "),e.j41(17,"code"),e.EFF(18,"useFactory"),e.k0s(),e.EFF(19," syntax. The factory returns a "),e.j41(20,"code"),e.EFF(21,"Promise"),e.k0s(),e.EFF(22,", and the factory function can "),e.j41(23,"code"),e.EFF(24,"await"),e.k0s(),e.EFF(25," asynchronous tasks. Nest will await resolution of the promise before instantiating any class that depends on (injects) such a provider."),e.k0s(),e.j41(26,"pre")(27,"code",6),e.EFF(28,"\n{\n  provide: 'ASYNC_CONNECTION',\n  useFactory: async () => {\n    const connection = await createConnection(options);\n    return connection;\n  },\n}\n"),e.k0s()(),e.j41(29,"blockquote",7)(30,"strong"),e.EFF(31,"Hint"),e.k0s(),e.EFF(32," Learn more about custom provider syntax "),e.j41(33,"a",8),e.EFF(34,"here"),e.k0s(),e.EFF(35,".\n"),e.k0s(),e.j41(36,"h4",9)(37,"span"),e.EFF(38,"Injection"),e.k0s()(),e.j41(39,"p"),e.EFF(40,"Asynchronous providers are injected to other components by their tokens, like any other provider. In the example above, you would use the construct "),e.j41(41,"code"),e.EFF(42,"@Inject('ASYNC_CONNECTION')"),e.k0s(),e.EFF(43,"."),e.k0s(),e.j41(44,"h4",10)(45,"span"),e.EFF(46,"Example"),e.k0s()(),e.j41(47,"p")(48,"a",11),e.EFF(49,"The TypeORM recipe"),e.k0s(),e.EFF(50," has a more substantial example of an asynchronous provider."),e.k0s()())},dependencies:[l.a,p.Wk],encapsulation:2,changeDetection:0})}return t})();var E=c(5119),f=c(5663);let S=(()=>{class t extends F.y{static \u0275fac=(()=>{let o;return function(n){return(o||(o=e.xGo(t)))(n||t)}})();static \u0275cmp=e.VBU({type:t,selectors:[["app-circular-dependency"]],features:[e.Vt3],decls:150,vars:24,consts:[["contentReference",""],["app7dd26d90cca5e6111617846dcacfea4739789c1d",""],["app631bda62a6b65fe9cc8a2c02eff5e212143a7d89",""],["app8f576d1d3a684b11683613cf7a8554fd13575514",""],["app2af03202de25995451b938e33ae758d29e413a50",""],[1,"content"],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/circular-dependency.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","circular-dependency"],[1,"warning"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/nest/issues/1181#issuecomment-430197191"],["appAnchor","","id","forward-reference"],[1,"filename"],[1,"language-typescript"],[1,"info"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/nest/issues/5778"],["appAnchor","","id","moduleref-class-alternative"],["routerLink","/fundamentals/module-ref"],["appAnchor","","id","module-forward-reference"]],template:function(s,n){if(1&s&&(e.j41(0,"div",5,0)(2,"div",6)(3,"a",7),e.nrm(4,"i",8),e.k0s()(),e.j41(5,"h3",9),e.EFF(6,"Circular dependency"),e.k0s(),e.j41(7,"p"),e.EFF(8,"A circular dependency occurs when two classes depend on each other. For example, class A needs class B, and class B also needs class A. Circular dependencies can arise in Nest between modules and between providers."),e.k0s(),e.j41(9,"p"),e.EFF(10,"While circular dependencies should be avoided where possible, you can't always do so. In such cases, Nest enables resolving circular dependencies between providers in two ways. In this chapter, we describe using "),e.j41(11,"strong"),e.EFF(12,"forward referencing"),e.k0s(),e.EFF(13," as one technique, and using the "),e.j41(14,"strong"),e.EFF(15,"ModuleRef"),e.k0s(),e.EFF(16," class to retrieve a provider instance from the DI container as another."),e.k0s(),e.j41(17,"p"),e.EFF(18,"We also describe resolving circular dependencies between modules."),e.k0s(),e.j41(19,"blockquote",10)(20,"strong"),e.EFF(21,"Warning"),e.k0s(),e.EFF(22,' A circular dependency might also be caused when using "barrel files"/index.ts files to group imports. Barrel files should be omitted when it comes to module/provider classes. For example, barrel files should not be used when importing files within the same directory as the barrel file, i.e. '),e.j41(23,"code"),e.EFF(24,"cats/cats.controller"),e.k0s(),e.EFF(25," should not import "),e.j41(26,"code"),e.EFF(27,"cats"),e.k0s(),e.EFF(28," to import the "),e.j41(29,"code"),e.EFF(30,"cats/cats.service"),e.k0s(),e.EFF(31," file. For more details please also see "),e.j41(32,"a",11),e.EFF(33,"this github issue"),e.k0s(),e.EFF(34,".\n"),e.k0s(),e.j41(35,"h4",12)(36,"span"),e.EFF(37,"Forward reference"),e.k0s()(),e.j41(38,"p"),e.EFF(39,"A "),e.j41(40,"strong"),e.EFF(41,"forward reference"),e.k0s(),e.EFF(42," allows Nest to reference classes which aren't yet defined using the "),e.j41(43,"code"),e.EFF(44,"forwardRef()"),e.k0s(),e.EFF(45," utility function. For example, if "),e.j41(46,"code"),e.EFF(47,"CatsService"),e.k0s(),e.EFF(48," and "),e.j41(49,"code"),e.EFF(50,"CommonService"),e.k0s(),e.EFF(51," depend on each other, both sides of the relationship can use "),e.j41(52,"code"),e.EFF(53,"@Inject()"),e.k0s(),e.EFF(54," and the "),e.j41(55,"code"),e.EFF(56,"forwardRef()"),e.k0s(),e.EFF(57," utility to resolve the circular dependency. Otherwise Nest won't instantiate them because all of the essential metadata won't be available. Here's an example:"),e.k0s(),e.j41(58,"span",13),e.EFF(59),e.nI1(60,"extension"),e.nrm(61,"app-tabs",null,1),e.k0s(),e.j41(63,"pre")(64,"code",14),e.EFF(65,"\n@Injectable()\nexport class CatsService {\n  constructor(\n    @Inject(forwardRef(() => CommonService))\n    private commonService: CommonService,\n  ) {}\n}\n"),e.k0s()(),e.j41(66,"pre")(67,"code",14),e.EFF(68,"\n@Injectable()\n@Dependencies(forwardRef(() => CommonService))\nexport class CatsService {\n  constructor(commonService) {\n    this.commonService = commonService;\n  }\n}\n"),e.k0s()(),e.j41(69,"blockquote",15)(70,"strong"),e.EFF(71,"Hint"),e.k0s(),e.EFF(72," The "),e.j41(73,"code"),e.EFF(74,"forwardRef()"),e.k0s(),e.EFF(75," function is imported from the "),e.j41(76,"code"),e.EFF(77,"@nestjs/common"),e.k0s(),e.EFF(78," package.\n"),e.k0s(),e.j41(79,"p"),e.EFF(80,"That covers one side of the relationship. Now let's do the same with "),e.j41(81,"code"),e.EFF(82,"CommonService"),e.k0s(),e.EFF(83,":"),e.k0s(),e.j41(84,"span",13),e.EFF(85),e.nI1(86,"extension"),e.nrm(87,"app-tabs",null,2),e.k0s(),e.j41(89,"pre")(90,"code",14),e.EFF(91,"\n@Injectable()\nexport class CommonService {\n  constructor(\n    @Inject(forwardRef(() => CatsService))\n    private catsService: CatsService,\n  ) {}\n}\n"),e.k0s()(),e.j41(92,"pre")(93,"code",14),e.EFF(94,"\n@Injectable()\n@Dependencies(forwardRef(() => CatsService))\nexport class CommonService {\n  constructor(catsService) {\n    this.catsService = catsService;\n  }\n}\n"),e.k0s()(),e.j41(95,"blockquote",10)(96,"strong"),e.EFF(97,"Warning"),e.k0s(),e.EFF(98," The order of instantiation is indeterminate. Make sure your code does not depend on which constructor is called first. Having circular dependencies depend on providers with "),e.j41(99,"code"),e.EFF(100,"Scope.REQUEST"),e.k0s(),e.EFF(101," can lead to undefined dependencies. More information available "),e.j41(102,"a",16),e.EFF(103,"here"),e.k0s()(),e.j41(104,"h4",17)(105,"span"),e.EFF(106,"ModuleRef class alternative"),e.k0s()(),e.j41(107,"p"),e.EFF(108,"An alternative to using "),e.j41(109,"code"),e.EFF(110,"forwardRef()"),e.k0s(),e.EFF(111," is to refactor your code and use the "),e.j41(112,"code"),e.EFF(113,"ModuleRef"),e.k0s(),e.EFF(114," class to retrieve a provider on one side of the (otherwise) circular relationship. Learn more about the "),e.j41(115,"code"),e.EFF(116,"ModuleRef"),e.k0s(),e.EFF(117," utility class "),e.j41(118,"a",18),e.EFF(119,"here"),e.k0s(),e.EFF(120,"."),e.k0s(),e.j41(121,"h4",19)(122,"span"),e.EFF(123,"Module forward reference"),e.k0s()(),e.j41(124,"p"),e.EFF(125,"In order to resolve circular dependencies between modules, use the same "),e.j41(126,"code"),e.EFF(127,"forwardRef()"),e.k0s(),e.EFF(128," utility function on both sides of the modules association. For example:"),e.k0s(),e.j41(129,"span",13),e.EFF(130),e.nI1(131,"extension"),e.nrm(132,"app-tabs",null,3),e.k0s(),e.j41(134,"pre")(135,"code",14),e.EFF(136,"\n@Module({\n  imports: [forwardRef(() => CatsModule)],\n})\nexport class CommonModule {}\n"),e.k0s()(),e.j41(137,"p"),e.EFF(138,"That covers one side of the relationship. Now let's do the same with "),e.j41(139,"code"),e.EFF(140,"CatsModule"),e.k0s(),e.EFF(141,":"),e.k0s(),e.j41(142,"span",13),e.EFF(143),e.nI1(144,"extension"),e.nrm(145,"app-tabs",null,4),e.k0s(),e.j41(147,"pre")(148,"code",14),e.EFF(149,"\n@Module({\n  imports: [forwardRef(() => CommonModule)],\n})\nexport class CatsModule {}\n"),e.k0s()()()),2&s){const a=e.sdS(62),r=e.sdS(88),i=e.sdS(133),d=e.sdS(146);e.R7$(59),e.SpI(" ",e.i5U(60,12,"cats.service",a.isJsActive),"\n"),e.R7$(4),e.AVh("hide",a.isJsActive),e.R7$(3),e.AVh("hide",!a.isJsActive),e.R7$(19),e.SpI(" ",e.i5U(86,15,"common.service",r.isJsActive),"\n"),e.R7$(4),e.AVh("hide",r.isJsActive),e.R7$(3),e.AVh("hide",!r.isJsActive),e.R7$(38),e.SpI(" ",e.i5U(131,18,"common.module",i.isJsActive),"\n"),e.R7$(13),e.SpI(" ",e.i5U(144,21,"cats.module",d.isJsActive),"\n")}},dependencies:[E.O,l.a,p.Wk,f.M],encapsulation:2,changeDetection:0})}return t})();var k=c(5749);let A=(()=>{class t extends F.y{static \u0275fac=(()=>{let o;return function(n){return(o||(o=e.xGo(t)))(n||t)}})();static \u0275cmp=e.VBU({type:t,selectors:[["app-dependency-injection"]],features:[e.Vt3],decls:465,vars:36,consts:[["contentReference",""],["app3d53b1c89b6590a604d288e575a25d0c54267cb1",""],["app6a4bafd71724fb23eaacf9e47c80f9cd1e3f6129",""],["app693b16a49e02d8b89d2095d60e5fae4444605cce",""],["app607c60adc478fae3972f6b816be6416a75f6c10a",""],["appa3dac8e2f3aebd54633a42cd78bfcbf7196c1113",""],["app354cdb0bb023083abf804f600aac992b93ec12c5",""],["app6376e93d15bf8b4fa3000211174852e0fdca2879",""],[1,"content"],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/dependency-injection.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","custom-providers"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/providers#dependency-injection"],["appAnchor","","id","di-fundamentals"],["rel","nofollow","target","_blank","href","https://en.wikipedia.org/wiki/Inversion_of_control"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/providers"],[1,"filename"],[1,"language-typescript"],["start","3"],["href","/fundamentals/custom-providers#standard-providers"],["appAnchor","","id","standard-providers"],["appAnchor","","id","custom-providers-1"],[1,"info"],["appAnchor","","id","value-providers-usevalue"],["rel","nofollow","target","_blank","href","https://www.typescriptlang.org/docs/handbook/type-compatibility.html"],["appAnchor","","id","non-class-based-provider-tokens"],["href","/fundamentals/custom-providers#di-fundamentals"],[1,"warning"],["rel","nofollow","target","_blank","href","https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol"],["rel","nofollow","target","_blank","href","https://www.typescriptlang.org/docs/handbook/enums.html"],["appAnchor","","id","class-providers-useclass"],["appAnchor","","id","factory-providers-usefactory"],["appAnchor","","id","alias-providers-useexisting"],["appAnchor","","id","non-service-based-providers"],["appAnchor","","id","export-custom-provider"]],template:function(s,n){if(1&s&&(e.j41(0,"div",8,0)(2,"div",9)(3,"a",10),e.nrm(4,"i",11),e.k0s()(),e.j41(5,"h3",12),e.EFF(6,"Custom providers"),e.k0s(),e.j41(7,"p"),e.EFF(8,"In earlier chapters, we touched on various aspects of "),e.j41(9,"strong"),e.EFF(10,"Dependency Injection (DI)"),e.k0s(),e.EFF(11," and how it is used in Nest. One example of this is the "),e.j41(12,"a",13),e.EFF(13,"constructor based"),e.k0s(),e.EFF(14," dependency injection used to inject instances (often service providers) into classes. You won't be surprised to learn that Dependency Injection is built into the Nest core in a fundamental way. So far, we've only explored one main pattern. As your application grows more complex, you may need to take advantage of the full features of the DI system, so let's explore them in more detail."),e.k0s(),e.j41(15,"h4",14)(16,"span"),e.EFF(17,"DI fundamentals"),e.k0s()(),e.j41(18,"p"),e.EFF(19,"Dependency injection is an "),e.j41(20,"a",15),e.EFF(21,"inversion of control (IoC)"),e.k0s(),e.EFF(22," technique wherein you delegate instantiation of dependencies to the IoC container (in our case, the NestJS runtime system), instead of doing it in your own code imperatively. Let's examine what's happening in this example from the "),e.j41(23,"a",16),e.EFF(24,"Providers chapter"),e.k0s(),e.EFF(25,"."),e.k0s(),e.j41(26,"p"),e.EFF(27,"First, we define a provider. The "),e.j41(28,"code"),e.EFF(29,"@Injectable()"),e.k0s(),e.EFF(30," decorator marks the "),e.j41(31,"code"),e.EFF(32,"CatsService"),e.k0s(),e.EFF(33," class as a provider."),e.k0s(),e.j41(34,"span",17),e.EFF(35),e.nI1(36,"extension"),e.nrm(37,"app-tabs",null,1),e.k0s(),e.j41(39,"pre")(40,"code",18),e.EFF(41,"\nimport { Injectable } from '@nestjs/common';\nimport { Cat } from './interfaces/cat.interface';\n\n@Injectable()\nexport class CatsService {\n  private readonly cats: Cat[] = [];\n\n  findAll(): Cat[] {\n    return this.cats;\n  }\n}\n"),e.k0s()(),e.j41(42,"pre")(43,"code",18),e.EFF(44,"\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class CatsService {\n  constructor() {\n    this.cats = [];\n  }\n\n  findAll() {\n    return this.cats;\n  }\n}\n"),e.k0s()(),e.j41(45,"p"),e.EFF(46,"Then we request that Nest inject the provider into our controller class:"),e.k0s(),e.j41(47,"span",17),e.EFF(48),e.nI1(49,"extension"),e.nrm(50,"app-tabs",null,2),e.k0s(),e.j41(52,"pre")(53,"code",18),e.EFF(54,"\nimport { Controller, Get } from '@nestjs/common';\nimport { CatsService } from './cats.service';\nimport { Cat } from './interfaces/cat.interface';\n\n@Controller('cats')\nexport class CatsController {\n  constructor(private catsService: CatsService) {}\n\n  @Get()\n  async findAll(): Promise<Cat[]> {\n    return this.catsService.findAll();\n  }\n}\n"),e.k0s()(),e.j41(55,"pre")(56,"code",18),e.EFF(57,"\nimport { Controller, Get, Bind, Dependencies } from '@nestjs/common';\nimport { CatsService } from './cats.service';\n\n@Controller('cats')\n@Dependencies(CatsService)\nexport class CatsController {\n  constructor(catsService) {\n    this.catsService = catsService;\n  }\n\n  @Get()\n  async findAll() {\n    return this.catsService.findAll();\n  }\n}\n"),e.k0s()(),e.j41(58,"p"),e.EFF(59,"Finally, we register the provider with the Nest IoC container:"),e.k0s(),e.j41(60,"span",17),e.EFF(61),e.nI1(62,"extension"),e.nrm(63,"app-tabs",null,3),e.k0s(),e.j41(65,"pre")(66,"code",18),e.EFF(67,"\nimport { Module } from '@nestjs/common';\nimport { CatsController } from './cats/cats.controller';\nimport { CatsService } from './cats/cats.service';\n\n@Module({\n  controllers: [CatsController],\n  providers: [CatsService],\n})\nexport class AppModule {}\n"),e.k0s()(),e.j41(68,"p"),e.EFF(69,"What exactly is happening under the covers to make this work? There are three key steps in the process:"),e.k0s(),e.j41(70,"ol")(71,"li"),e.EFF(72,"In "),e.j41(73,"code"),e.EFF(74,"cats.service.ts"),e.k0s(),e.EFF(75,", the "),e.j41(76,"code"),e.EFF(77,"@Injectable()"),e.k0s(),e.EFF(78," decorator declares the "),e.j41(79,"code"),e.EFF(80,"CatsService"),e.k0s(),e.EFF(81," class as a class that can be managed by the Nest IoC container."),e.k0s(),e.j41(82,"li"),e.EFF(83,"In "),e.j41(84,"code"),e.EFF(85,"cats.controller.ts"),e.k0s(),e.EFF(86,", "),e.j41(87,"code"),e.EFF(88,"CatsController"),e.k0s(),e.EFF(89," declares a dependency on the "),e.j41(90,"code"),e.EFF(91,"CatsService"),e.k0s(),e.EFF(92," token with constructor injection:"),e.k0s()(),e.j41(93,"pre")(94,"code",18),e.EFF(95,"\n  constructor(private catsService: CatsService)\n"),e.k0s()(),e.j41(96,"ol",19)(97,"li"),e.EFF(98,"In "),e.j41(99,"code"),e.EFF(100,"app.module.ts"),e.k0s(),e.EFF(101,", we associate the token "),e.j41(102,"code"),e.EFF(103,"CatsService"),e.k0s(),e.EFF(104," with the class "),e.j41(105,"code"),e.EFF(106,"CatsService"),e.k0s(),e.EFF(107," from the "),e.j41(108,"code"),e.EFF(109,"cats.service.ts"),e.k0s(),e.EFF(110," file. We'll "),e.j41(111,"a",20),e.EFF(112,"see below"),e.k0s(),e.EFF(113," exactly how this association (also called "),e.j41(114,"em"),e.EFF(115,"registration"),e.k0s(),e.EFF(116,") occurs."),e.k0s()(),e.j41(117,"p"),e.EFF(118,"When the Nest IoC container instantiates a "),e.j41(119,"code"),e.EFF(120,"CatsController"),e.k0s(),e.EFF(121,", it first looks for any dependencies*. When it finds the "),e.j41(122,"code"),e.EFF(123,"CatsService"),e.k0s(),e.EFF(124," dependency, it performs a lookup on the "),e.j41(125,"code"),e.EFF(126,"CatsService"),e.k0s(),e.EFF(127," token, which returns the "),e.j41(128,"code"),e.EFF(129,"CatsService"),e.k0s(),e.EFF(130," class, per the registration step (#3 above). Assuming "),e.j41(131,"code"),e.EFF(132,"SINGLETON"),e.k0s(),e.EFF(133," scope (the default behavior), Nest will then either create an instance of "),e.j41(134,"code"),e.EFF(135,"CatsService"),e.k0s(),e.EFF(136,", cache it, and return it, or if one is already cached, return the existing instance."),e.k0s(),e.j41(137,"p"),e.EFF(138,'*This explanation is a bit simplified to illustrate the point. One important area we glossed over is that the process of analyzing the code for dependencies is very sophisticated, and happens during application bootstrapping. One key feature is that dependency analysis (or "creating the dependency graph"), is '),e.j41(139,"strong"),e.EFF(140,"transitive"),e.k0s(),e.EFF(141,". In the above example, if the "),e.j41(142,"code"),e.EFF(143,"CatsService"),e.k0s(),e.EFF(144,' itself had dependencies, those too would be resolved. The dependency graph ensures that dependencies are resolved in the correct order - essentially "bottom up". This mechanism relieves the developer from having to manage such complex dependency graphs.'),e.k0s(),e.j41(145,"p"),e.nrm(146,"app-banner-courses"),e.k0s(),e.j41(147,"h4",21)(148,"span"),e.EFF(149,"Standard providers"),e.k0s()(),e.j41(150,"p"),e.EFF(151,"Let's take a closer look at the "),e.j41(152,"code"),e.EFF(153,"@Module()"),e.k0s(),e.EFF(154," decorator. In "),e.j41(155,"code"),e.EFF(156,"app.module"),e.k0s(),e.EFF(157,", we declare:"),e.k0s(),e.j41(158,"pre")(159,"code",18),e.EFF(160,"\n@Module({\n  controllers: [CatsController],\n  providers: [CatsService],\n})\n"),e.k0s()(),e.j41(161,"p"),e.EFF(162,"The "),e.j41(163,"code"),e.EFF(164,"providers"),e.k0s(),e.EFF(165," property takes an array of "),e.j41(166,"code"),e.EFF(167,"providers"),e.k0s(),e.EFF(168,". So far, we've supplied those providers via a list of class names. In fact, the syntax "),e.j41(169,"code"),e.EFF(170,"providers: [CatsService]"),e.k0s(),e.EFF(171," is short-hand for the more complete syntax:"),e.k0s(),e.j41(172,"pre")(173,"code",18),e.EFF(174,"\nproviders: [\n  {\n    provide: CatsService,\n    useClass: CatsService,\n  },\n];\n"),e.k0s()(),e.j41(175,"p"),e.EFF(176,"Now that we see this explicit construction, we can understand the registration process. Here, we are clearly associating the token "),e.j41(177,"code"),e.EFF(178,"CatsService"),e.k0s(),e.EFF(179," with the class "),e.j41(180,"code"),e.EFF(181,"CatsService"),e.k0s(),e.EFF(182,". The short-hand notation is merely a convenience to simplify the most common use-case, where the token is used to request an instance of a class by the same name."),e.k0s(),e.j41(183,"h4",22)(184,"span"),e.EFF(185,"Custom providers"),e.k0s()(),e.j41(186,"p"),e.EFF(187,"What happens when your requirements go beyond those offered by "),e.j41(188,"em"),e.EFF(189,"Standard providers"),e.k0s(),e.EFF(190,"? Here are a few examples:"),e.k0s(),e.j41(191,"ul")(192,"li"),e.EFF(193,"You want to create a custom instance instead of having Nest instantiate (or return a cached instance of) a class"),e.k0s(),e.j41(194,"li"),e.EFF(195,"You want to re-use an existing class in a second dependency"),e.k0s(),e.j41(196,"li"),e.EFF(197,"You want to override a class with a mock version for testing"),e.k0s()(),e.j41(198,"p"),e.EFF(199,"Nest allows you to define Custom providers to handle these cases. It provides several ways to define custom providers. Let's walk through them."),e.k0s(),e.j41(200,"blockquote",23)(201,"strong"),e.EFF(202,"Hint"),e.k0s(),e.EFF(203," If you are having problems with dependency resolution you can set the "),e.j41(204,"code"),e.EFF(205,"NEST_DEBUG"),e.k0s(),e.EFF(206," environment variable and get extra dependency resolution logs during startup.\n"),e.k0s(),e.j41(207,"h4",24)(208,"span"),e.EFF(209,"Value providers: "),e.j41(210,"code"),e.EFF(211,"useValue"),e.k0s()()(),e.j41(212,"p"),e.EFF(213,"The "),e.j41(214,"code"),e.EFF(215,"useValue"),e.k0s(),e.EFF(216," syntax is useful for injecting a constant value, putting an external library into the Nest container, or replacing a real implementation with a mock object. Let's say you'd like to force Nest to use a mock "),e.j41(217,"code"),e.EFF(218,"CatsService"),e.k0s(),e.EFF(219," for testing purposes."),e.k0s(),e.j41(220,"pre")(221,"code",18),e.EFF(222,"\nimport { CatsService } from './cats.service';\n\nconst mockCatsService = {\n  /* mock implementation\n  ...\n  */\n};\n\n@Module({\n  imports: [CatsModule],\n  providers: [\n    {\n      provide: CatsService,\n      useValue: mockCatsService,\n    },\n  ],\n})\nexport class AppModule {}\n"),e.k0s()(),e.j41(223,"p"),e.EFF(224,"In this example, the "),e.j41(225,"code"),e.EFF(226,"CatsService"),e.k0s(),e.EFF(227," token will resolve to the "),e.j41(228,"code"),e.EFF(229,"mockCatsService"),e.k0s(),e.EFF(230," mock object. "),e.j41(231,"code"),e.EFF(232,"useValue"),e.k0s(),e.EFF(233," requires a value - in this case a literal object that has the same interface as the "),e.j41(234,"code"),e.EFF(235,"CatsService"),e.k0s(),e.EFF(236," class it is replacing. Because of TypeScript's "),e.j41(237,"a",25),e.EFF(238,"structural typing"),e.k0s(),e.EFF(239,", you can use any object that has a compatible interface, including a literal object or a class instance instantiated with "),e.j41(240,"code"),e.EFF(241,"new"),e.k0s(),e.EFF(242,"."),e.k0s(),e.j41(243,"h4",26)(244,"span"),e.EFF(245,"Non-class-based provider tokens"),e.k0s()(),e.j41(246,"p"),e.EFF(247,"So far, we've used class names as our provider tokens (the value of the "),e.j41(248,"code"),e.EFF(249,"provide"),e.k0s(),e.EFF(250," property in a provider listed in the "),e.j41(251,"code"),e.EFF(252,"providers"),e.k0s(),e.EFF(253," array). This is matched by the standard pattern used with "),e.j41(254,"a",13),e.EFF(255,"constructor based injection"),e.k0s(),e.EFF(256,", where the token is also a class name. (Refer back to "),e.j41(257,"a",27),e.EFF(258,"DI Fundamentals"),e.k0s(),e.EFF(259," for a refresher on tokens if this concept isn't entirely clear). Sometimes, we may want the flexibility to use strings or symbols as the DI token. For example:"),e.k0s(),e.j41(260,"pre")(261,"code",18),e.EFF(262,"\nimport { connection } from './connection';\n\n@Module({\n  providers: [\n    {\n      provide: 'CONNECTION',\n      useValue: connection,\n    },\n  ],\n})\nexport class AppModule {}\n"),e.k0s()(),e.j41(263,"p"),e.EFF(264,"In this example, we are associating a string-valued token ("),e.j41(265,"code"),e.EFF(266,"'CONNECTION'"),e.k0s(),e.EFF(267,") with a pre-existing "),e.j41(268,"code"),e.EFF(269,"connection"),e.k0s(),e.EFF(270," object we've imported from an external file."),e.k0s(),e.j41(271,"blockquote",28)(272,"strong"),e.EFF(273,"Notice"),e.k0s(),e.EFF(274," In addition to using strings as token values, you can also use JavaScript "),e.j41(275,"a",29),e.EFF(276,"symbols"),e.k0s(),e.EFF(277," or TypeScript "),e.j41(278,"a",30),e.EFF(279,"enums"),e.k0s(),e.EFF(280,".\n"),e.k0s(),e.j41(281,"p"),e.EFF(282,"We've previously seen how to inject a provider using the standard "),e.j41(283,"a",13),e.EFF(284,"constructor based injection"),e.k0s(),e.EFF(285," pattern. This pattern "),e.j41(286,"strong"),e.EFF(287,"requires"),e.k0s(),e.EFF(288," that the dependency be declared with a class name. The "),e.j41(289,"code"),e.EFF(290,"'CONNECTION'"),e.k0s(),e.EFF(291," custom provider uses a string-valued token. Let's see how to inject such a provider. To do so, we use the "),e.j41(292,"code"),e.EFF(293,"@Inject()"),e.k0s(),e.EFF(294," decorator. This decorator takes a single argument - the token."),e.k0s(),e.j41(295,"span",17),e.nrm(296,"app-tabs",null,4),e.k0s(),e.j41(298,"pre")(299,"code",18),e.EFF(300,"\n@Injectable()\nexport class CatsRepository {\n  constructor(@Inject('CONNECTION') connection: Connection) {}\n}\n"),e.k0s()(),e.j41(301,"pre")(302,"code",18),e.EFF(303,"\n@Injectable()\n@Dependencies('CONNECTION')\nexport class CatsRepository {\n  constructor(connection) {}\n}\n"),e.k0s()(),e.j41(304,"blockquote",23)(305,"strong"),e.EFF(306,"Hint"),e.k0s(),e.EFF(307," The "),e.j41(308,"code"),e.EFF(309,"@Inject()"),e.k0s(),e.EFF(310," decorator is imported from "),e.j41(311,"code"),e.EFF(312,"@nestjs/common"),e.k0s(),e.EFF(313," package.\n"),e.k0s(),e.j41(314,"p"),e.EFF(315,"While we directly use the string "),e.j41(316,"code"),e.EFF(317,"'CONNECTION'"),e.k0s(),e.EFF(318," in the above examples for illustration purposes, for clean code organization, it's best practice to define tokens in a separate file, such as "),e.j41(319,"code"),e.EFF(320,"constants.ts"),e.k0s(),e.EFF(321,". Treat them much as you would symbols or enums that are defined in their own file and imported where needed."),e.k0s(),e.j41(322,"h4",31)(323,"span"),e.EFF(324,"Class providers: "),e.j41(325,"code"),e.EFF(326,"useClass"),e.k0s()()(),e.j41(327,"p"),e.EFF(328,"The "),e.j41(329,"code"),e.EFF(330,"useClass"),e.k0s(),e.EFF(331," syntax allows you to dynamically determine a class that a token should resolve to. For example, suppose we have an abstract (or default) "),e.j41(332,"code"),e.EFF(333,"ConfigService"),e.k0s(),e.EFF(334," class. Depending on the current environment, we want Nest to provide a different implementation of the configuration service. The following code implements such a strategy."),e.k0s(),e.j41(335,"pre")(336,"code",18),e.EFF(337,"\nconst configServiceProvider = {\n  provide: ConfigService,\n  useClass:\n    process.env.NODE_ENV === 'development'\n      ? DevelopmentConfigService\n      : ProductionConfigService,\n};\n\n@Module({\n  providers: [configServiceProvider],\n})\nexport class AppModule {}\n"),e.k0s()(),e.j41(338,"p"),e.EFF(339,"Let's look at a couple of details in this code sample. You'll notice that we define "),e.j41(340,"code"),e.EFF(341,"configServiceProvider"),e.k0s(),e.EFF(342," with a literal object first, then pass it in the module decorator's "),e.j41(343,"code"),e.EFF(344,"providers"),e.k0s(),e.EFF(345," property. This is just a bit of code organization, but is functionally equivalent to the examples we've used thus far in this chapter."),e.k0s(),e.j41(346,"p"),e.EFF(347,"Also, we have used the "),e.j41(348,"code"),e.EFF(349,"ConfigService"),e.k0s(),e.EFF(350," class name as our token. For any class that depends on "),e.j41(351,"code"),e.EFF(352,"ConfigService"),e.k0s(),e.EFF(353,", Nest will inject an instance of the provided class ("),e.j41(354,"code"),e.EFF(355,"DevelopmentConfigService"),e.k0s(),e.EFF(356," or "),e.j41(357,"code"),e.EFF(358,"ProductionConfigService"),e.k0s(),e.EFF(359,") overriding any default implementation that may have been declared elsewhere (e.g., a "),e.j41(360,"code"),e.EFF(361,"ConfigService"),e.k0s(),e.EFF(362," declared with an "),e.j41(363,"code"),e.EFF(364,"@Injectable()"),e.k0s(),e.EFF(365," decorator)."),e.k0s(),e.j41(366,"h4",32)(367,"span"),e.EFF(368,"Factory providers: "),e.j41(369,"code"),e.EFF(370,"useFactory"),e.k0s()()(),e.j41(371,"p"),e.EFF(372,"The "),e.j41(373,"code"),e.EFF(374,"useFactory"),e.k0s(),e.EFF(375," syntax allows for creating providers "),e.j41(376,"strong"),e.EFF(377,"dynamically"),e.k0s(),e.EFF(378,". The actual provider will be supplied by the value returned from a factory function. The factory function can be as simple or complex as needed. A simple factory may not depend on any other providers. A more complex factory can itself inject other providers it needs to compute its result. For the latter case, the factory provider syntax has a pair of related mechanisms:"),e.k0s(),e.j41(379,"ol")(380,"li"),e.EFF(381,"The factory function can accept (optional) arguments."),e.k0s(),e.j41(382,"li"),e.EFF(383,"The (optional) "),e.j41(384,"code"),e.EFF(385,"inject"),e.k0s(),e.EFF(386," property accepts an array of providers that Nest will resolve and pass as arguments to the factory function during the instantiation process. Also, these providers can be marked as optional. The two lists should be correlated: Nest will pass instances from the "),e.j41(387,"code"),e.EFF(388,"inject"),e.k0s(),e.EFF(389," list as arguments to the factory function in the same order. The example below demonstrates this."),e.k0s()(),e.j41(390,"span",17),e.nrm(391,"app-tabs",null,5),e.k0s(),e.j41(393,"pre")(394,"code",18),e.EFF(395,"\nconst connectionProvider = {\n  provide: 'CONNECTION',\n  useFactory: (optionsProvider: MyOptionsProvider, optionalProvider?: string) => {\n    const options = optionsProvider.get();\n    return new DatabaseConnection(options);\n  },\n  inject: [MyOptionsProvider, { token: 'SomeOptionalProvider', optional: true }],\n  //       \\______________/             \\__________________/\n  //        This provider                The provider with this token\n  //        is mandatory.                can resolve to `undefined`.\n};\n\n@Module({\n  providers: [\n    connectionProvider,\n    MyOptionsProvider, // class-based provider\n    // { provide: 'SomeOptionalProvider', useValue: 'anything' },\n  ],\n})\nexport class AppModule {}\n"),e.k0s()(),e.j41(396,"pre")(397,"code",18),e.EFF(398,"\nconst connectionProvider = {\n  provide: 'CONNECTION',\n  useFactory: (optionsProvider, optionalProvider) => {\n    const options = optionsProvider.get();\n    return new DatabaseConnection(options);\n  },\n  inject: [MyOptionsProvider, { token: 'SomeOptionalProvider', optional: true }],\n  //       \\______________/            \\__________________/\n  //        This provider               The provider with this token\n  //        is mandatory.               can resolve to `undefined`.\n};\n\n@Module({\n  providers: [\n    connectionProvider,\n    MyOptionsProvider, // class-base provider\n    // { provide: 'SomeOptionalProvider', useValue: 'anything' },\n  ],\n})\nexport class AppModule {}\n"),e.k0s()(),e.j41(399,"h4",33)(400,"span"),e.EFF(401,"Alias providers: "),e.j41(402,"code"),e.EFF(403,"useExisting"),e.k0s()()(),e.j41(404,"p"),e.EFF(405,"The "),e.j41(406,"code"),e.EFF(407,"useExisting"),e.k0s(),e.EFF(408," syntax allows you to create aliases for existing providers. This creates two ways to access the same provider. In the example below, the (string-based) token "),e.j41(409,"code"),e.EFF(410,"'AliasedLoggerService'"),e.k0s(),e.EFF(411," is an alias for the (class-based) token "),e.j41(412,"code"),e.EFF(413,"LoggerService"),e.k0s(),e.EFF(414,". Assume we have two different dependencies, one for "),e.j41(415,"code"),e.EFF(416,"'AliasedLoggerService'"),e.k0s(),e.EFF(417," and one for "),e.j41(418,"code"),e.EFF(419,"LoggerService"),e.k0s(),e.EFF(420,". If both dependencies are specified with "),e.j41(421,"code"),e.EFF(422,"SINGLETON"),e.k0s(),e.EFF(423," scope, they'll both resolve to the same instance."),e.k0s(),e.j41(424,"pre")(425,"code",18),e.EFF(426,"\n@Injectable()\nclass LoggerService {\n  /* implementation details */\n}\n\nconst loggerAliasProvider = {\n  provide: 'AliasedLoggerService',\n  useExisting: LoggerService,\n};\n\n@Module({\n  providers: [LoggerService, loggerAliasProvider],\n})\nexport class AppModule {}\n"),e.k0s()(),e.j41(427,"h4",34)(428,"span"),e.EFF(429,"Non-service based providers"),e.k0s()(),e.j41(430,"p"),e.EFF(431,"While providers often supply services, they are not limited to that usage. A provider can supply "),e.j41(432,"strong"),e.EFF(433,"any"),e.k0s(),e.EFF(434," value. For example, a provider may supply an array of configuration objects based on the current environment, as shown below:"),e.k0s(),e.j41(435,"pre")(436,"code",18),e.EFF(437,"\nconst configFactory = {\n  provide: 'CONFIG',\n  useFactory: () => {\n    return process.env.NODE_ENV === 'development' ? devConfig : prodConfig;\n  },\n};\n\n@Module({\n  providers: [configFactory],\n})\nexport class AppModule {}\n"),e.k0s()(),e.j41(438,"h4",35)(439,"span"),e.EFF(440,"Export custom provider"),e.k0s()(),e.j41(441,"p"),e.EFF(442,"Like any provider, a custom provider is scoped to its declaring module. To make it visible to other modules, it must be exported. To export a custom provider, we can either use its token or the full provider object."),e.k0s(),e.j41(443,"p"),e.EFF(444,"The following example shows exporting using the token:"),e.k0s(),e.j41(445,"span",17),e.nrm(446,"app-tabs",null,6),e.k0s(),e.j41(448,"pre")(449,"code",18),e.EFF(450,"\nconst connectionFactory = {\n  provide: 'CONNECTION',\n  useFactory: (optionsProvider: OptionsProvider) => {\n    const options = optionsProvider.get();\n    return new DatabaseConnection(options);\n  },\n  inject: [OptionsProvider],\n};\n\n@Module({\n  providers: [connectionFactory],\n  exports: ['CONNECTION'],\n})\nexport class AppModule {}\n"),e.k0s()(),e.j41(451,"pre")(452,"code",18),e.EFF(453,"\nconst connectionFactory = {\n  provide: 'CONNECTION',\n  useFactory: (optionsProvider) => {\n    const options = optionsProvider.get();\n    return new DatabaseConnection(options);\n  },\n  inject: [OptionsProvider],\n};\n\n@Module({\n  providers: [connectionFactory],\n  exports: ['CONNECTION'],\n})\nexport class AppModule {}\n"),e.k0s()(),e.j41(454,"p"),e.EFF(455,"Alternatively, export with the full provider object:"),e.k0s(),e.j41(456,"span",17),e.nrm(457,"app-tabs",null,7),e.k0s(),e.j41(459,"pre")(460,"code",18),e.EFF(461,"\nconst connectionFactory = {\n  provide: 'CONNECTION',\n  useFactory: (optionsProvider: OptionsProvider) => {\n    const options = optionsProvider.get();\n    return new DatabaseConnection(options);\n  },\n  inject: [OptionsProvider],\n};\n\n@Module({\n  providers: [connectionFactory],\n  exports: [connectionFactory],\n})\nexport class AppModule {}\n"),e.k0s()(),e.j41(462,"pre")(463,"code",18),e.EFF(464,"\nconst connectionFactory = {\n  provide: 'CONNECTION',\n  useFactory: (optionsProvider) => {\n    const options = optionsProvider.get();\n    return new DatabaseConnection(options);\n  },\n  inject: [OptionsProvider],\n};\n\n@Module({\n  providers: [connectionFactory],\n  exports: [connectionFactory],\n})\nexport class AppModule {}\n"),e.k0s()()()),2&s){const a=e.sdS(38),r=e.sdS(51),i=e.sdS(64),d=e.sdS(297),m=e.sdS(392),u=e.sdS(447),h=e.sdS(458);e.R7$(35),e.SpI(" ",e.i5U(36,27,"cats.service",a.isJsActive),"\n"),e.R7$(4),e.AVh("hide",a.isJsActive),e.R7$(3),e.AVh("hide",!a.isJsActive),e.R7$(6),e.SpI(" ",e.i5U(49,30,"cats.controller",r.isJsActive),"\n"),e.R7$(4),e.AVh("hide",r.isJsActive),e.R7$(3),e.AVh("hide",!r.isJsActive),e.R7$(6),e.SpI(" ",e.i5U(62,33,"app.module",i.isJsActive),"\n"),e.R7$(237),e.AVh("hide",d.isJsActive),e.R7$(3),e.AVh("hide",!d.isJsActive),e.R7$(92),e.AVh("hide",m.isJsActive),e.R7$(3),e.AVh("hide",!m.isJsActive),e.R7$(52),e.AVh("hide",u.isJsActive),e.R7$(3),e.AVh("hide",!u.isJsActive),e.R7$(8),e.AVh("hide",h.isJsActive),e.R7$(3),e.AVh("hide",!h.isJsActive)}},dependencies:[E.O,l.a,k.Q,f.M],encapsulation:2,changeDetection:0})}return t})();var b=c(7077);let I=(()=>{class t extends F.y{static \u0275fac=(()=>{let o;return function(n){return(o||(o=e.xGo(t)))(n||t)}})();static \u0275cmp=e.VBU({type:t,selectors:[["app-dynamic-modules"]],features:[e.Vt3],decls:888,vars:28,consts:[["contentReference",""],["app3b04dc40b7f2c410a55bc2ecb955356f6ef37c94",""],["appd70b7a3e81816e692bbe31b0b6a531824b69442d",""],["app76452c1f856097f7336c58ce6d7e271ae265319a",""],[1,"content"],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/dynamic-modules.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","dynamic-modules"],["routerLink","/modules"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/modules#dynamic-modules"],["appAnchor","","id","introduction"],["routerLink","/providers"],["routerLink","/controllers"],[1,"language-typescript"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/fundamentals/custom-providers"],["appAnchor","","id","dynamic-module-use-case"],["appAnchor","","id","config-module-example"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/techniques/configuration#service"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/nest/tree/master/sample/25-dynamic-modules"],[1,"info"],["appAnchor","","id","module-configuration"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/fundamentals/custom-providers#non-service-based-providers"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/fundamentals/custom-providers#non-class-based-provider-tokens"],["appAnchor","","id","example"],["appAnchor","","id","community-guidelines"],["appAnchor","","id","configurable-module-builder"],[1,"filename"],["appAnchor","","id","custom-method-key"],["appAnchor","","id","custom-options-factory-class"],["appAnchor","","id","extra-options"],["href","/modules#dynamic-modules"],["appAnchor","","id","extending-auto-generated-methods"]],template:function(s,n){if(1&s&&(e.j41(0,"div",4,0)(2,"div",5)(3,"a",6),e.nrm(4,"i",7),e.k0s()(),e.j41(5,"h3",8),e.EFF(6,"Dynamic modules"),e.k0s(),e.j41(7,"p"),e.EFF(8,"The "),e.j41(9,"a",9),e.EFF(10,"Modules chapter"),e.k0s(),e.EFF(11," covers the basics of Nest modules, and includes a brief introduction to "),e.j41(12,"a",10),e.EFF(13,"dynamic modules"),e.k0s(),e.EFF(14,". This chapter expands on the subject of dynamic modules. Upon completion, you should have a good grasp of what they are and how and when to use them."),e.k0s(),e.j41(15,"h4",11)(16,"span"),e.EFF(17,"Introduction"),e.k0s()(),e.j41(18,"p"),e.EFF(19,"Most application code examples in the "),e.j41(20,"strong"),e.EFF(21,"Overview"),e.k0s(),e.EFF(22," section of the documentation make use of regular, or static, modules. Modules define groups of components like "),e.j41(23,"a",12),e.EFF(24,"providers"),e.k0s(),e.EFF(25," and "),e.j41(26,"a",13),e.EFF(27,"controllers"),e.k0s(),e.EFF(28," that fit together as a modular part of an overall application. They provide an execution context, or scope, for these components. For example, providers defined in a module are visible to other members of the module without the need to export them. When a provider needs to be visible outside of a module, it is first exported from its host module, and then imported into its consuming module."),e.k0s(),e.j41(29,"p"),e.EFF(30,"Let's walk through a familiar example."),e.k0s(),e.j41(31,"p"),e.EFF(32,"First, we'll define a "),e.j41(33,"code"),e.EFF(34,"UsersModule"),e.k0s(),e.EFF(35," to provide and export a "),e.j41(36,"code"),e.EFF(37,"UsersService"),e.k0s(),e.EFF(38,". "),e.j41(39,"code"),e.EFF(40,"UsersModule"),e.k0s(),e.EFF(41," is the "),e.j41(42,"strong"),e.EFF(43,"host"),e.k0s(),e.EFF(44," module for "),e.j41(45,"code"),e.EFF(46,"UsersService"),e.k0s(),e.EFF(47,"."),e.k0s(),e.j41(48,"pre")(49,"code",14),e.EFF(50,"\nimport { Module } from '@nestjs/common';\nimport { UsersService } from './users.service';\n\n@Module({\n  providers: [UsersService],\n  exports: [UsersService],\n})\nexport class UsersModule {}\n"),e.k0s()(),e.j41(51,"p"),e.EFF(52,"Next, we'll define an "),e.j41(53,"code"),e.EFF(54,"AuthModule"),e.k0s(),e.EFF(55,", which imports "),e.j41(56,"code"),e.EFF(57,"UsersModule"),e.k0s(),e.EFF(58,", making "),e.j41(59,"code"),e.EFF(60,"UsersModule"),e.k0s(),e.EFF(61,"'s exported providers available inside "),e.j41(62,"code"),e.EFF(63,"AuthModule"),e.k0s(),e.EFF(64,":"),e.k0s(),e.j41(65,"pre")(66,"code",14),e.EFF(67,"\nimport { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { UsersModule } from '../users/users.module';\n\n@Module({\n  imports: [UsersModule],\n  providers: [AuthService],\n  exports: [AuthService],\n})\nexport class AuthModule {}\n"),e.k0s()(),e.j41(68,"p"),e.EFF(69,"These constructs allow us to inject "),e.j41(70,"code"),e.EFF(71,"UsersService"),e.k0s(),e.EFF(72," in, for example, the "),e.j41(73,"code"),e.EFF(74,"AuthService"),e.k0s(),e.EFF(75," that is hosted in "),e.j41(76,"code"),e.EFF(77,"AuthModule"),e.k0s(),e.EFF(78,":"),e.k0s(),e.j41(79,"pre")(80,"code",14),e.EFF(81,"\nimport { Injectable } from '@nestjs/common';\nimport { UsersService } from '../users/users.service';\n\n@Injectable()\nexport class AuthService {\n  constructor(private usersService: UsersService) {}\n  /*\n    Implementation that makes use of this.usersService\n  */\n}\n"),e.k0s()(),e.j41(82,"p"),e.EFF(83,"We'll refer to this as "),e.j41(84,"strong"),e.EFF(85,"static"),e.k0s(),e.EFF(86," module binding. All the information Nest needs to wire together the modules has already been declared in the host and consuming modules. Let's unpack what's happening during this process. Nest makes "),e.j41(87,"code"),e.EFF(88,"UsersService"),e.k0s(),e.EFF(89," available inside "),e.j41(90,"code"),e.EFF(91,"AuthModule"),e.k0s(),e.EFF(92," by:"),e.k0s(),e.j41(93,"ol")(94,"li"),e.EFF(95,"Instantiating "),e.j41(96,"code"),e.EFF(97,"UsersModule"),e.k0s(),e.EFF(98,", including transitively importing other modules that "),e.j41(99,"code"),e.EFF(100,"UsersModule"),e.k0s(),e.EFF(101," itself consumes, and transitively resolving any dependencies (see "),e.j41(102,"a",15),e.EFF(103,"Custom providers"),e.k0s(),e.EFF(104,")."),e.k0s(),e.j41(105,"li"),e.EFF(106,"Instantiating "),e.j41(107,"code"),e.EFF(108,"AuthModule"),e.k0s(),e.EFF(109,", and making "),e.j41(110,"code"),e.EFF(111,"UsersModule"),e.k0s(),e.EFF(112,"'s exported providers available to components in "),e.j41(113,"code"),e.EFF(114,"AuthModule"),e.k0s(),e.EFF(115," (just as if they had been declared in "),e.j41(116,"code"),e.EFF(117,"AuthModule"),e.k0s(),e.EFF(118,")."),e.k0s(),e.j41(119,"li"),e.EFF(120,"Injecting an instance of "),e.j41(121,"code"),e.EFF(122,"UsersService"),e.k0s(),e.EFF(123," in "),e.j41(124,"code"),e.EFF(125,"AuthService"),e.k0s(),e.EFF(126,"."),e.k0s()(),e.j41(127,"h4",16)(128,"span"),e.EFF(129,"Dynamic module use case"),e.k0s()(),e.j41(130,"p"),e.EFF(131,"With static module binding, there's no opportunity for the consuming module to "),e.j41(132,"strong"),e.EFF(133,"influence"),e.k0s(),e.EFF(134,' how providers from the host module are configured. Why does this matter? Consider the case where we have a general purpose module that needs to behave differently in different use cases. This is analogous to the concept of a "plugin" in many systems, where a generic facility requires some configuration before it can be used by a consumer.'),e.k0s(),e.j41(135,"p"),e.EFF(136,"A good example with Nest is a "),e.j41(137,"strong"),e.EFF(138,"configuration module"),e.k0s(),e.EFF(139,". Many applications find it useful to externalize configuration details by using a configuration module. This makes it easy to dynamically change the application settings in different deployments: e.g., a development database for developers, a staging database for the staging/testing environment, etc. By delegating the management of configuration parameters to a configuration module, the application source code remains independent of configuration parameters."),e.k0s(),e.j41(140,"p"),e.EFF(141,'The challenge is that the configuration module itself, since it\'s generic (similar to a "plugin"), needs to be customized by its consuming module. This is where '),e.j41(142,"em"),e.EFF(143,"dynamic modules"),e.k0s(),e.EFF(144," come into play. Using dynamic module features, we can make our configuration module "),e.j41(145,"strong"),e.EFF(146,"dynamic"),e.k0s(),e.EFF(147," so that the consuming module can use an API to control how the configuration module is customized at the time it is imported."),e.k0s(),e.j41(148,"p"),e.EFF(149,"In other words, dynamic modules provide an API for importing one module into another, and customizing the properties and behavior of that module when it is imported, as opposed to using the static bindings we've seen so far."),e.k0s(),e.j41(150,"p"),e.nrm(151,"app-banner-devtools"),e.k0s(),e.j41(152,"h4",17)(153,"span"),e.EFF(154,"Config module example"),e.k0s()(),e.j41(155,"p"),e.EFF(156,"We'll be using the basic version of the example code from the "),e.j41(157,"a",18),e.EFF(158,"configuration chapter"),e.k0s(),e.EFF(159," for this section. The completed version as of the end of this chapter is available as a working "),e.j41(160,"a",19),e.EFF(161,"example here"),e.k0s(),e.EFF(162,"."),e.k0s(),e.j41(163,"p"),e.EFF(164,"Our requirement is to make "),e.j41(165,"code"),e.EFF(166,"ConfigModule"),e.k0s(),e.EFF(167," accept an "),e.j41(168,"code"),e.EFF(169,"options"),e.k0s(),e.EFF(170," object to customize it. Here's the feature we want to support. The basic sample hard-codes the location of the "),e.j41(171,"code"),e.EFF(172,".env"),e.k0s(),e.EFF(173," file to be in the project root folder. Let's suppose we want to make that configurable, such that you can manage your "),e.j41(174,"code"),e.EFF(175,".env"),e.k0s(),e.EFF(176," files in any folder of your choosing. For example, imagine you want to store your various "),e.j41(177,"code"),e.EFF(178,".env"),e.k0s(),e.EFF(179," files in a folder under the project root called "),e.j41(180,"code"),e.EFF(181,"config"),e.k0s(),e.EFF(182," (i.e., a sibling folder to "),e.j41(183,"code"),e.EFF(184,"src"),e.k0s(),e.EFF(185,"). You'd like to be able to choose different folders when using the "),e.j41(186,"code"),e.EFF(187,"ConfigModule"),e.k0s(),e.EFF(188," in different projects."),e.k0s(),e.j41(189,"p"),e.EFF(190,"Dynamic modules give us the ability to pass parameters into the module being imported so we can change its behavior. Let's see how this works. It's helpful if we start from the end-goal of how this might look from the consuming module's perspective, and then work backwards. First, let's quickly review the example of "),e.j41(191,"em"),e.EFF(192,"statically"),e.k0s(),e.EFF(193," importing the "),e.j41(194,"code"),e.EFF(195,"ConfigModule"),e.k0s(),e.EFF(196," (i.e., an approach which has no ability to influence the behavior of the imported module). Pay close attention to the "),e.j41(197,"code"),e.EFF(198,"imports"),e.k0s(),e.EFF(199," array in the "),e.j41(200,"code"),e.EFF(201,"@Module()"),e.k0s(),e.EFF(202," decorator:"),e.k0s(),e.j41(203,"pre")(204,"code",14),e.EFF(205,"\nimport { Module } from '@nestjs/common';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { ConfigModule } from './config/config.module';\n\n@Module({\n  imports: [ConfigModule],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n"),e.k0s()(),e.j41(206,"p"),e.EFF(207,"Let's consider what a "),e.j41(208,"em"),e.EFF(209,"dynamic module"),e.k0s(),e.EFF(210," import, where we're passing in a configuration object, might look like. Compare the difference in the "),e.j41(211,"code"),e.EFF(212,"imports"),e.k0s(),e.EFF(213," array between these two examples:"),e.k0s(),e.j41(214,"pre")(215,"code",14),e.EFF(216,"\nimport { Module } from '@nestjs/common';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { ConfigModule } from './config/config.module';\n\n@Module({\n  imports: [ConfigModule.register({ folder: './config' })],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n"),e.k0s()(),e.j41(217,"p"),e.EFF(218,"Let's see what's happening in the dynamic example above. What are the moving parts?"),e.k0s(),e.j41(219,"ol")(220,"li")(221,"code"),e.EFF(222,"ConfigModule"),e.k0s(),e.EFF(223," is a normal class, so we can infer that it must have a "),e.j41(224,"strong"),e.EFF(225,"static method"),e.k0s(),e.EFF(226," called "),e.j41(227,"code"),e.EFF(228,"register()"),e.k0s(),e.EFF(229,". We know it's static because we're calling it on the "),e.j41(230,"code"),e.EFF(231,"ConfigModule"),e.k0s(),e.EFF(232," class, not on an "),e.j41(233,"strong"),e.EFF(234,"instance"),e.k0s(),e.EFF(235," of the class. Note: this method, which we will create soon, can have any arbitrary name, but by convention we should call it either "),e.j41(236,"code"),e.EFF(237,"forRoot()"),e.k0s(),e.EFF(238," or "),e.j41(239,"code"),e.EFF(240,"register()"),e.k0s(),e.EFF(241,"."),e.k0s(),e.j41(242,"li"),e.EFF(243,"The "),e.j41(244,"code"),e.EFF(245,"register()"),e.k0s(),e.EFF(246," method is defined by us, so we can accept any input arguments we like. In this case, we're going to accept a simple "),e.j41(247,"code"),e.EFF(248,"options"),e.k0s(),e.EFF(249," object with suitable properties, which is the typical case."),e.k0s(),e.j41(250,"li"),e.EFF(251,"We can infer that the "),e.j41(252,"code"),e.EFF(253,"register()"),e.k0s(),e.EFF(254," method must return something like a "),e.j41(255,"code"),e.EFF(256,"module"),e.k0s(),e.EFF(257," since its return value appears in the familiar "),e.j41(258,"code"),e.EFF(259,"imports"),e.k0s(),e.EFF(260," list, which we've seen so far includes a list of modules."),e.k0s()(),e.j41(261,"p"),e.EFF(262,"In fact, what our "),e.j41(263,"code"),e.EFF(264,"register()"),e.k0s(),e.EFF(265," method will return is a "),e.j41(266,"code"),e.EFF(267,"DynamicModule"),e.k0s(),e.EFF(268,". A dynamic module is nothing more than a module created at run-time, with the same exact properties as a static module, plus one additional property called "),e.j41(269,"code"),e.EFF(270,"module"),e.k0s(),e.EFF(271,". Let's quickly review a sample static module declaration, paying close attention to the module options passed in to the decorator:"),e.k0s(),e.j41(272,"pre")(273,"code",14),e.EFF(274,"\n@Module({\n  imports: [DogsModule],\n  controllers: [CatsController],\n  providers: [CatsService],\n  exports: [CatsService]\n})\n"),e.k0s()(),e.j41(275,"p"),e.EFF(276,"Dynamic modules must return an object with the exact same interface, plus one additional property called "),e.j41(277,"code"),e.EFF(278,"module"),e.k0s(),e.EFF(279,". The "),e.j41(280,"code"),e.EFF(281,"module"),e.k0s(),e.EFF(282," property serves as the name of the module, and should be the same as the class name of the module, as shown in the example below."),e.k0s(),e.j41(283,"blockquote",20)(284,"strong"),e.EFF(285,"Hint"),e.k0s(),e.EFF(286," For a dynamic module, all properties of the module options object are optional "),e.j41(287,"strong"),e.EFF(288,"except"),e.k0s(),e.j41(289,"code"),e.EFF(290,"module"),e.k0s(),e.EFF(291,".\n"),e.k0s(),e.j41(292,"p"),e.EFF(293,"What about the static "),e.j41(294,"code"),e.EFF(295,"register()"),e.k0s(),e.EFF(296," method? We can now see that its job is to return an object that has the "),e.j41(297,"code"),e.EFF(298,"DynamicModule"),e.k0s(),e.EFF(299," interface. When we call it, we are effectively providing a module to the "),e.j41(300,"code"),e.EFF(301,"imports"),e.k0s(),e.EFF(302," list, similar to the way we would do so in the static case by listing a module class name. In other words, the dynamic module API simply returns a module, but rather than fix the properties in the "),e.j41(303,"code"),e.EFF(304,"@Module"),e.k0s(),e.EFF(305," decorator, we specify them programmatically."),e.k0s(),e.j41(306,"p"),e.EFF(307,"There are still a couple of details to cover to help make the picture complete:"),e.k0s(),e.j41(308,"ol")(309,"li"),e.EFF(310,"We can now state that the "),e.j41(311,"code"),e.EFF(312,"@Module()"),e.k0s(),e.EFF(313," decorator's "),e.j41(314,"code"),e.EFF(315,"imports"),e.k0s(),e.EFF(316," property can take not only a module class name (e.g., "),e.j41(317,"code"),e.EFF(318,"imports: [UsersModule]"),e.k0s(),e.EFF(319,"), but also a function "),e.j41(320,"strong"),e.EFF(321,"returning"),e.k0s(),e.EFF(322," a dynamic module (e.g., "),e.j41(323,"code"),e.EFF(324,"imports: [ConfigModule.register(...)]"),e.k0s(),e.EFF(325,")."),e.k0s(),e.j41(326,"li"),e.EFF(327,"A dynamic module can itself import other modules. We won't do so in this example, but if the dynamic module depends on providers from other modules, you would import them using the optional "),e.j41(328,"code"),e.EFF(329,"imports"),e.k0s(),e.EFF(330," property. Again, this is exactly analogous to the way you'd declare metadata for a static module using the "),e.j41(331,"code"),e.EFF(332,"@Module()"),e.k0s(),e.EFF(333," decorator."),e.k0s()(),e.j41(334,"p"),e.EFF(335,"Armed with this understanding, we can now look at what our dynamic "),e.j41(336,"code"),e.EFF(337,"ConfigModule"),e.k0s(),e.EFF(338," declaration must look like. Let's take a crack at it."),e.k0s(),e.j41(339,"pre")(340,"code",14),e.EFF(341,"\nimport { DynamicModule, Module } from '@nestjs/common';\nimport { ConfigService } from './config.service';\n\n@Module({})\nexport class ConfigModule {\n  static register(): DynamicModule {\n    return {\n      module: ConfigModule,\n      providers: [ConfigService],\n      exports: [ConfigService],\n    };\n  }\n}\n"),e.k0s()(),e.j41(342,"p"),e.EFF(343,"It should now be clear how the pieces tie together. Calling "),e.j41(344,"code"),e.EFF(345,"ConfigModule.register(...)"),e.k0s(),e.EFF(346," returns a "),e.j41(347,"code"),e.EFF(348,"DynamicModule"),e.k0s(),e.EFF(349," object with properties which are essentially the same as those that, until now, we've provided as metadata via the "),e.j41(350,"code"),e.EFF(351,"@Module()"),e.k0s(),e.EFF(352," decorator."),e.k0s(),e.j41(353,"blockquote",20)(354,"strong"),e.EFF(355,"Hint"),e.k0s(),e.EFF(356," Import "),e.j41(357,"code"),e.EFF(358,"DynamicModule"),e.k0s(),e.EFF(359," from "),e.j41(360,"code"),e.EFF(361,"@nestjs/common"),e.k0s(),e.EFF(362,".\n"),e.k0s(),e.j41(363,"p"),e.EFF(364,"Our dynamic module isn't very interesting yet, however, as we haven't introduced any capability to "),e.j41(365,"strong"),e.EFF(366,"configure"),e.k0s(),e.EFF(367," it as we said we would like to do. Let's address that next."),e.k0s(),e.j41(368,"h4",21)(369,"span"),e.EFF(370,"Module configuration"),e.k0s()(),e.j41(371,"p"),e.EFF(372,"The obvious solution for customizing the behavior of the "),e.j41(373,"code"),e.EFF(374,"ConfigModule"),e.k0s(),e.EFF(375," is to pass it an "),e.j41(376,"code"),e.EFF(377,"options"),e.k0s(),e.EFF(378," object in the static "),e.j41(379,"code"),e.EFF(380,"register()"),e.k0s(),e.EFF(381," method, as we guessed above. Let's look once again at our consuming module's "),e.j41(382,"code"),e.EFF(383,"imports"),e.k0s(),e.EFF(384," property:"),e.k0s(),e.j41(385,"pre")(386,"code",14),e.EFF(387,"\nimport { Module } from '@nestjs/common';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { ConfigModule } from './config/config.module';\n\n@Module({\n  imports: [ConfigModule.register({ folder: './config' })],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n"),e.k0s()(),e.j41(388,"p"),e.EFF(389,"That nicely handles passing an "),e.j41(390,"code"),e.EFF(391,"options"),e.k0s(),e.EFF(392," object to our dynamic module. How do we then use that "),e.j41(393,"code"),e.EFF(394,"options"),e.k0s(),e.EFF(395," object in the "),e.j41(396,"code"),e.EFF(397,"ConfigModule"),e.k0s(),e.EFF(398,"? Let's consider that for a minute. We know that our "),e.j41(399,"code"),e.EFF(400,"ConfigModule"),e.k0s(),e.EFF(401," is basically a host for providing and exporting an injectable service - the "),e.j41(402,"code"),e.EFF(403,"ConfigService"),e.k0s(),e.EFF(404," - for use by other providers. It's actually our "),e.j41(405,"code"),e.EFF(406,"ConfigService"),e.k0s(),e.EFF(407," that needs to read the "),e.j41(408,"code"),e.EFF(409,"options"),e.k0s(),e.EFF(410," object to customize its behavior. Let's assume for the moment that we know how to somehow get the "),e.j41(411,"code"),e.EFF(412,"options"),e.k0s(),e.EFF(413," from the "),e.j41(414,"code"),e.EFF(415,"register()"),e.k0s(),e.EFF(416," method into the "),e.j41(417,"code"),e.EFF(418,"ConfigService"),e.k0s(),e.EFF(419,". With that assumption, we can make a few changes to the service to customize its behavior based on the properties from the "),e.j41(420,"code"),e.EFF(421,"options"),e.k0s(),e.EFF(422," object. ("),e.j41(423,"strong"),e.EFF(424,"Note"),e.k0s(),e.EFF(425,": for the time being, since we "),e.j41(426,"em"),e.EFF(427,"haven't"),e.k0s(),e.EFF(428," actually determined how to pass it in, we'll just hard-code "),e.j41(429,"code"),e.EFF(430,"options"),e.k0s(),e.EFF(431,". We'll fix this in a minute)."),e.k0s(),e.j41(432,"pre")(433,"code",14),e.EFF(434,"\nimport { Injectable } from '@nestjs/common';\nimport * as dotenv from 'dotenv';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { EnvConfig } from './interfaces';\n\n@Injectable()\nexport class ConfigService {\n  private readonly envConfig: EnvConfig;\n\n  constructor() {\n    const options = { folder: './config' };\n\n    const filePath = `${process.env.NODE_ENV || 'development'}.env`;\n    const envFile = path.resolve(__dirname, '../../', options.folder, filePath);\n    this.envConfig = dotenv.parse(fs.readFileSync(envFile));\n  }\n\n  get(key: string): string {\n    return this.envConfig[key];\n  }\n}\n"),e.k0s()(),e.j41(435,"p"),e.EFF(436,"Now our "),e.j41(437,"code"),e.EFF(438,"ConfigService"),e.k0s(),e.EFF(439," knows how to find the "),e.j41(440,"code"),e.EFF(441,".env"),e.k0s(),e.EFF(442," file in the folder we've specified in "),e.j41(443,"code"),e.EFF(444,"options"),e.k0s(),e.EFF(445,"."),e.k0s(),e.j41(446,"p"),e.EFF(447,"Our remaining task is to somehow inject the "),e.j41(448,"code"),e.EFF(449,"options"),e.k0s(),e.EFF(450," object from the "),e.j41(451,"code"),e.EFF(452,"register()"),e.k0s(),e.EFF(453," step into our "),e.j41(454,"code"),e.EFF(455,"ConfigService"),e.k0s(),e.EFF(456,". And of course, we'll use "),e.j41(457,"em"),e.EFF(458,"dependency injection"),e.k0s(),e.EFF(459," to do it. This is a key point, so make sure you understand it. Our "),e.j41(460,"code"),e.EFF(461,"ConfigModule"),e.k0s(),e.EFF(462," is providing "),e.j41(463,"code"),e.EFF(464,"ConfigService"),e.k0s(),e.EFF(465,". "),e.j41(466,"code"),e.EFF(467,"ConfigService"),e.k0s(),e.EFF(468," in turn depends on the "),e.j41(469,"code"),e.EFF(470,"options"),e.k0s(),e.EFF(471," object that is only supplied at run-time. So, at run-time, we'll need to first bind the "),e.j41(472,"code"),e.EFF(473,"options"),e.k0s(),e.EFF(474," object to the Nest IoC container, and then have Nest inject it into our "),e.j41(475,"code"),e.EFF(476,"ConfigService"),e.k0s(),e.EFF(477,". Remember from the "),e.j41(478,"strong"),e.EFF(479,"Custom providers"),e.k0s(),e.EFF(480," chapter that providers can "),e.j41(481,"a",22),e.EFF(482,"include any value"),e.k0s(),e.EFF(483," not just services, so we're fine using dependency injection to handle a simple "),e.j41(484,"code"),e.EFF(485,"options"),e.k0s(),e.EFF(486," object."),e.k0s(),e.j41(487,"p"),e.EFF(488,"Let's tackle binding the options object to the IoC container first. We do this in our static "),e.j41(489,"code"),e.EFF(490,"register()"),e.k0s(),e.EFF(491," method. Remember that we are dynamically constructing a module, and one of the properties of a module is its list of providers. So what we need to do is define our options object as a provider. This will make it injectable into the "),e.j41(492,"code"),e.EFF(493,"ConfigService"),e.k0s(),e.EFF(494,", which we'll take advantage of in the next step. In the code below, pay attention to the "),e.j41(495,"code"),e.EFF(496,"providers"),e.k0s(),e.EFF(497," array:"),e.k0s(),e.j41(498,"pre")(499,"code",14),e.EFF(500,"\nimport { DynamicModule, Module } from '@nestjs/common';\nimport { ConfigService } from './config.service';\n\n@Module({})\nexport class ConfigModule {\n  static register(options: Record<string, any>): DynamicModule {\n    return {\n      module: ConfigModule,\n      providers: [\n        {\n          provide: 'CONFIG_OPTIONS',\n          useValue: options,\n        },\n        ConfigService,\n      ],\n      exports: [ConfigService],\n    };\n  }\n}\n"),e.k0s()(),e.j41(501,"p"),e.EFF(502,"Now we can complete the process by injecting the "),e.j41(503,"code"),e.EFF(504,"'CONFIG_OPTIONS'"),e.k0s(),e.EFF(505," provider into the "),e.j41(506,"code"),e.EFF(507,"ConfigService"),e.k0s(),e.EFF(508,". Recall that when we define a provider using a non-class token we need to use the "),e.j41(509,"code"),e.EFF(510,"@Inject()"),e.k0s(),e.EFF(511," decorator "),e.j41(512,"a",23),e.EFF(513,"as described here"),e.k0s(),e.EFF(514,"."),e.k0s(),e.j41(515,"pre")(516,"code",14),e.EFF(517,"\nimport * as dotenv from 'dotenv';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { Injectable, Inject } from '@nestjs/common';\nimport { EnvConfig } from './interfaces';\n\n@Injectable()\nexport class ConfigService {\n  private readonly envConfig: EnvConfig;\n\n  constructor(@Inject('CONFIG_OPTIONS') private options: Record<string, any>) {\n    const filePath = `${process.env.NODE_ENV || 'development'}.env`;\n    const envFile = path.resolve(__dirname, '../../', options.folder, filePath);\n    this.envConfig = dotenv.parse(fs.readFileSync(envFile));\n  }\n\n  get(key: string): string {\n    return this.envConfig[key];\n  }\n}\n"),e.k0s()(),e.j41(518,"p"),e.EFF(519,"One final note: for simplicity we used a string-based injection token ("),e.j41(520,"code"),e.EFF(521,"'CONFIG_OPTIONS'"),e.k0s(),e.EFF(522,") above, but best practice is to define it as a constant (or "),e.j41(523,"code"),e.EFF(524,"Symbol"),e.k0s(),e.EFF(525,") in a separate file, and import that file. For example:"),e.k0s(),e.j41(526,"pre")(527,"code",14),e.EFF(528,"\nexport const CONFIG_OPTIONS = 'CONFIG_OPTIONS';\n"),e.k0s()(),e.j41(529,"h4",24)(530,"span"),e.EFF(531,"Example"),e.k0s()(),e.j41(532,"p"),e.EFF(533,"A full example of the code in this chapter can be found "),e.j41(534,"a",19),e.EFF(535,"here"),e.k0s(),e.EFF(536,"."),e.k0s(),e.j41(537,"h4",25)(538,"span"),e.EFF(539,"Community guidelines"),e.k0s()(),e.j41(540,"p"),e.EFF(541,"You may have seen the use for methods like "),e.j41(542,"code"),e.EFF(543,"forRoot"),e.k0s(),e.EFF(544,", "),e.j41(545,"code"),e.EFF(546,"register"),e.k0s(),e.EFF(547,", and "),e.j41(548,"code"),e.EFF(549,"forFeature"),e.k0s(),e.EFF(550," around some of the "),e.j41(551,"code"),e.EFF(552,"@nestjs/"),e.k0s(),e.EFF(553," packages and may be wondering what the difference for all of these methods are. There is no hard rule about this, but the "),e.j41(554,"code"),e.EFF(555,"@nestjs/"),e.k0s(),e.EFF(556," packages try to follow these guidelines:"),e.k0s(),e.j41(557,"p"),e.EFF(558,"When creating a module with:"),e.k0s(),e.j41(559,"ul")(560,"li")(561,"p")(562,"code"),e.EFF(563,"register"),e.k0s(),e.EFF(564,", you are expecting to configure a dynamic module with a specific configuration for use only by the calling module. For example, with Nest's "),e.j41(565,"code"),e.EFF(566,"@nestjs/axios"),e.k0s(),e.EFF(567,": "),e.j41(568,"code"),e.EFF(569),e.k0s(),e.EFF(570,". If, in another module you use "),e.j41(571,"code"),e.EFF(572),e.k0s(),e.EFF(573,", it will have the different configuration. You can do this for as many modules as you want."),e.k0s()(),e.j41(574,"li")(575,"p")(576,"code"),e.EFF(577,"forRoot"),e.k0s(),e.EFF(578,", you are expecting to configure a dynamic module once and reuse that configuration in multiple places (though possibly unknowingly as it's abstracted away). This is why you have one "),e.j41(579,"code"),e.EFF(580,"GraphQLModule.forRoot()"),e.k0s(),e.EFF(581,", one "),e.j41(582,"code"),e.EFF(583,"TypeOrmModule.forRoot()"),e.k0s(),e.EFF(584,", etc."),e.k0s()(),e.j41(585,"li")(586,"p")(587,"code"),e.EFF(588,"forFeature"),e.k0s(),e.EFF(589,", you are expecting to use the configuration of a dynamic module's "),e.j41(590,"code"),e.EFF(591,"forRoot"),e.k0s(),e.EFF(592," but need to modify some configuration specific to the calling module's needs (i.e. which repository this module should have access to, or the context that a logger should use.)"),e.k0s()()(),e.j41(593,"p"),e.EFF(594,"All of these, usually, have their "),e.j41(595,"code"),e.EFF(596,"async"),e.k0s(),e.EFF(597," counterparts as well, "),e.j41(598,"code"),e.EFF(599,"registerAsync"),e.k0s(),e.EFF(600,", "),e.j41(601,"code"),e.EFF(602,"forRootAsync"),e.k0s(),e.EFF(603,", and "),e.j41(604,"code"),e.EFF(605,"forFeatureAsync"),e.k0s(),e.EFF(606,", that mean the same thing, but use Nest's Dependency Injection for the configuration as well."),e.k0s(),e.j41(607,"h4",26)(608,"span"),e.EFF(609,"Configurable module builder"),e.k0s()(),e.j41(610,"p"),e.EFF(611,"As manually creating highly configurable, dynamic modules that expose "),e.j41(612,"code"),e.EFF(613,"async"),e.k0s(),e.EFF(614," methods ("),e.j41(615,"code"),e.EFF(616,"registerAsync"),e.k0s(),e.EFF(617,", "),e.j41(618,"code"),e.EFF(619,"forRootAsync"),e.k0s(),e.EFF(620,", etc.) is quite complicated, especially for newcomers, Nest exposes the "),e.j41(621,"code"),e.EFF(622,"ConfigurableModuleBuilder"),e.k0s(),e.EFF(623,' class that facilitates this process and lets you construct a module "blueprint" in just a few lines of code.'),e.k0s(),e.j41(624,"p"),e.EFF(625,"For example, let's take the example we used above ("),e.j41(626,"code"),e.EFF(627,"ConfigModule"),e.k0s(),e.EFF(628,") and convert it to use the "),e.j41(629,"code"),e.EFF(630,"ConfigurableModuleBuilder"),e.k0s(),e.EFF(631,". Before we start, let's make sure we create a dedicated interface that represents what options our "),e.j41(632,"code"),e.EFF(633,"ConfigModule"),e.k0s(),e.EFF(634," takes in."),e.k0s(),e.j41(635,"pre")(636,"code",14),e.EFF(637,"\nexport interface ConfigModuleOptions {\n  folder: string;\n}\n"),e.k0s()(),e.j41(638,"p"),e.EFF(639,"With this in place, create a new dedicated file (alongside the existing "),e.j41(640,"code"),e.EFF(641,"config.module.ts"),e.k0s(),e.EFF(642," file) and name it "),e.j41(643,"code"),e.EFF(644,"config.module-definition.ts"),e.k0s(),e.EFF(645,". In this file, let's utilize the "),e.j41(646,"code"),e.EFF(647,"ConfigurableModuleBuilder"),e.k0s(),e.EFF(648," to construct "),e.j41(649,"code"),e.EFF(650,"ConfigModule"),e.k0s(),e.EFF(651," definition."),e.k0s(),e.j41(652,"span",27),e.EFF(653),e.nI1(654,"extension"),e.nrm(655,"app-tabs",null,1),e.k0s(),e.j41(657,"pre")(658,"code",14),e.EFF(659,"\nimport { ConfigurableModuleBuilder } from '@nestjs/common';\nimport { ConfigModuleOptions } from './interfaces/config-module-options.interface';\n\nexport const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =\n  new ConfigurableModuleBuilder<ConfigModuleOptions>().build();\n"),e.k0s()(),e.j41(660,"pre")(661,"code",14),e.EFF(662,"\nimport { ConfigurableModuleBuilder } from '@nestjs/common';\n\nexport const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =\n  new ConfigurableModuleBuilder().build();\n"),e.k0s()(),e.j41(663,"p"),e.EFF(664,"Now let's open up the "),e.j41(665,"code"),e.EFF(666,"config.module.ts"),e.k0s(),e.EFF(667," file and modify its implementation to leverage the auto-generated "),e.j41(668,"code"),e.EFF(669,"ConfigurableModuleClass"),e.k0s(),e.EFF(670,":"),e.k0s(),e.j41(671,"pre")(672,"code",14),e.EFF(673,"\nimport { Module } from '@nestjs/common';\nimport { ConfigService } from './config.service';\nimport { ConfigurableModuleClass } from './config.module-definition';\n\n@Module({\n  providers: [ConfigService],\n  exports: [ConfigService],\n})\nexport class ConfigModule extends ConfigurableModuleClass {}\n"),e.k0s()(),e.j41(674,"p"),e.EFF(675,"Extending the "),e.j41(676,"code"),e.EFF(677,"ConfigurableModuleClass"),e.k0s(),e.EFF(678," means that "),e.j41(679,"code"),e.EFF(680,"ConfigModule"),e.k0s(),e.EFF(681," provides now not only the "),e.j41(682,"code"),e.EFF(683,"register"),e.k0s(),e.EFF(684," method (as previously with the custom implementation), but also the "),e.j41(685,"code"),e.EFF(686,"registerAsync"),e.k0s(),e.EFF(687," method which allows consumers asynchronously configure that module, for example, by supplying async factories:"),e.k0s(),e.j41(688,"pre")(689,"code",14),e.EFF(690,"\n@Module({\n  imports: [\n    ConfigModule.register({ folder: './config' }),\n    // or alternatively:\n    // ConfigModule.registerAsync({\n    //   useFactory: () => {\n    //     return {\n    //       folder: './config',\n    //     }\n    //   },\n    //   inject: [...any extra dependencies...]\n    // }),\n  ],\n})\nexport class AppModule {}\n"),e.k0s()(),e.j41(691,"p"),e.EFF(692,"Lastly, let's update the "),e.j41(693,"code"),e.EFF(694,"ConfigService"),e.k0s(),e.EFF(695," class to inject the generated module options' provider instead of the "),e.j41(696,"code"),e.EFF(697,"'CONFIG_OPTIONS'"),e.k0s(),e.EFF(698," that we used so far."),e.k0s(),e.j41(699,"pre")(700,"code",14),e.EFF(701,"\n@Injectable()\nexport class ConfigService {\n  constructor(@Inject(MODULE_OPTIONS_TOKEN) private options: ConfigModuleOptions) { ... }\n}\n"),e.k0s()(),e.j41(702,"h4",28)(703,"span"),e.EFF(704,"Custom method key"),e.k0s()(),e.j41(705,"p")(706,"code"),e.EFF(707,"ConfigurableModuleClass"),e.k0s(),e.EFF(708," by default provides the "),e.j41(709,"code"),e.EFF(710,"register"),e.k0s(),e.EFF(711," and its counterpart "),e.j41(712,"code"),e.EFF(713,"registerAsync"),e.k0s(),e.EFF(714," methods. To use a different method name, use the "),e.j41(715,"code"),e.EFF(716,"ConfigurableModuleBuilder#setClassMethodName"),e.k0s(),e.EFF(717," method, as follows:"),e.k0s(),e.j41(718,"span",27),e.EFF(719),e.nI1(720,"extension"),e.nrm(721,"app-tabs",null,2),e.k0s(),e.j41(723,"pre")(724,"code",14),e.EFF(725,"\nexport const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =\n  new ConfigurableModuleBuilder<ConfigModuleOptions>().setClassMethodName('forRoot').build();\n"),e.k0s()(),e.j41(726,"pre")(727,"code",14),e.EFF(728,"\nexport const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =\n  new ConfigurableModuleBuilder().setClassMethodName('forRoot').build();\n"),e.k0s()(),e.j41(729,"p"),e.EFF(730,"This construction will instruct "),e.j41(731,"code"),e.EFF(732,"ConfigurableModuleBuilder"),e.k0s(),e.EFF(733," to generate a class that exposes "),e.j41(734,"code"),e.EFF(735,"forRoot"),e.k0s(),e.EFF(736," and "),e.j41(737,"code"),e.EFF(738,"forRootAsync"),e.k0s(),e.EFF(739," instead. Example:"),e.k0s(),e.j41(740,"pre")(741,"code",14),e.EFF(742,"\n@Module({\n  imports: [\n    ConfigModule.forRoot({ folder: './config' }), // <-- note the use of \"forRoot\" instead of \"register\"\n    // or alternatively:\n    // ConfigModule.forRootAsync({\n    //   useFactory: () => {\n    //     return {\n    //       folder: './config',\n    //     }\n    //   },\n    //   inject: [...any extra dependencies...]\n    // }),\n  ],\n})\nexport class AppModule {}\n"),e.k0s()(),e.j41(743,"h4",29)(744,"span"),e.EFF(745,"Custom options factory class"),e.k0s()(),e.j41(746,"p"),e.EFF(747,"Since the "),e.j41(748,"code"),e.EFF(749,"registerAsync"),e.k0s(),e.EFF(750," method (or "),e.j41(751,"code"),e.EFF(752,"forRootAsync"),e.k0s(),e.EFF(753," or any other name, depending on the configuration) lets consumer pass a provider definition that resolves to the module configuration, a library consumer could potentially supply a class to be used to construct the configuration object."),e.k0s(),e.j41(754,"pre")(755,"code",14),e.EFF(756,"\n@Module({\n  imports: [\n    ConfigModule.registerAsync({\n      useClass: ConfigModuleOptionsFactory,\n    }),\n  ],\n})\nexport class AppModule {}\n"),e.k0s()(),e.j41(757,"p"),e.EFF(758,"This class, by default, must provide the "),e.j41(759,"code"),e.EFF(760,"create()"),e.k0s(),e.EFF(761," method that returns a module configuration object. However, if your library follows a different naming convention, you can change that behavior and instruct "),e.j41(762,"code"),e.EFF(763,"ConfigurableModuleBuilder"),e.k0s(),e.EFF(764," to expect a different method, for example, "),e.j41(765,"code"),e.EFF(766,"createConfigOptions"),e.k0s(),e.EFF(767,", using the "),e.j41(768,"code"),e.EFF(769,"ConfigurableModuleBuilder#setFactoryMethodName"),e.k0s(),e.EFF(770," method:"),e.k0s(),e.j41(771,"span",27),e.EFF(772),e.nI1(773,"extension"),e.nrm(774,"app-tabs",null,3),e.k0s(),e.j41(776,"pre")(777,"code",14),e.EFF(778,"\nexport const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =\n  new ConfigurableModuleBuilder<ConfigModuleOptions>().setFactoryMethodName('createConfigOptions').build();\n"),e.k0s()(),e.j41(779,"pre")(780,"code",14),e.EFF(781,"\nexport const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =\n  new ConfigurableModuleBuilder().setFactoryMethodName('createConfigOptions').build();\n"),e.k0s()(),e.j41(782,"p"),e.EFF(783,"Now, "),e.j41(784,"code"),e.EFF(785,"ConfigModuleOptionsFactory"),e.k0s(),e.EFF(786," class must expose the "),e.j41(787,"code"),e.EFF(788,"createConfigOptions"),e.k0s(),e.EFF(789," method (instead of "),e.j41(790,"code"),e.EFF(791,"create"),e.k0s(),e.EFF(792,"):"),e.k0s(),e.j41(793,"pre")(794,"code",14),e.EFF(795,'\n@Module({\n  imports: [\n    ConfigModule.registerAsync({\n      useClass: ConfigModuleOptionsFactory, // <-- this class must provide the "createConfigOptions" method\n    }),\n  ],\n})\nexport class AppModule {}\n'),e.k0s()(),e.j41(796,"h4",30)(797,"span"),e.EFF(798,"Extra options"),e.k0s()(),e.j41(799,"p"),e.EFF(800,"There are edge-cases when your module may need to take extra options that determine how it is supposed to behave (a nice example of such an option is the "),e.j41(801,"code"),e.EFF(802,"isGlobal"),e.k0s(),e.EFF(803," flag - or just "),e.j41(804,"code"),e.EFF(805,"global"),e.k0s(),e.EFF(806,") that at the same time, shouldn't be included in the "),e.j41(807,"code"),e.EFF(808,"MODULE_OPTIONS_TOKEN"),e.k0s(),e.EFF(809," provider (as they are irrelevant to services/providers registered within that module, for example, "),e.j41(810,"code"),e.EFF(811,"ConfigService"),e.k0s(),e.EFF(812," does not need to know whether its host module is registered as a global module)."),e.k0s(),e.j41(813,"p"),e.EFF(814,"In such cases, the "),e.j41(815,"code"),e.EFF(816,"ConfigurableModuleBuilder#setExtras"),e.k0s(),e.EFF(817," method can be used. See the following example:"),e.k0s(),e.j41(818,"pre")(819,"code",14),e.EFF(820,"\nexport const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } = new ConfigurableModuleBuilder<ConfigModuleOptions>()\n  .setExtras(\n    {\n      isGlobal: true,\n    },\n    (definition, extras) => ({\n      ...definition,\n      global: extras.isGlobal,\n    }),\n  )\n  .build();\n"),e.k0s()(),e.j41(821,"p"),e.EFF(822,"In the example above, the first argument passed into the "),e.j41(823,"code"),e.EFF(824,"setExtras"),e.k0s(),e.EFF(825,' method is an object containing default values for the "extra" properties. The second argument is a function that takes an auto-generated module definitions (with '),e.j41(826,"code"),e.EFF(827,"provider"),e.k0s(),e.EFF(828,", "),e.j41(829,"code"),e.EFF(830,"exports"),e.k0s(),e.EFF(831,", etc.) and "),e.j41(832,"code"),e.EFF(833,"extras"),e.k0s(),e.EFF(834," object which represents extra properties (either specified by the consumer or defaults). The returned value of this function is a modified module definition. In this specific example, we're taking the "),e.j41(835,"code"),e.EFF(836,"extras.isGlobal"),e.k0s(),e.EFF(837," property and assigning it to the "),e.j41(838,"code"),e.EFF(839,"global"),e.k0s(),e.EFF(840," property of the module definition (which in turn determines whether a module is global or not, read more "),e.j41(841,"a",31),e.EFF(842,"here"),e.k0s(),e.EFF(843,")."),e.k0s(),e.j41(844,"p"),e.EFF(845,"Now when consuming this module, the additional "),e.j41(846,"code"),e.EFF(847,"isGlobal"),e.k0s(),e.EFF(848," flag can be passed in, as follows:"),e.k0s(),e.j41(849,"pre")(850,"code",14),e.EFF(851,"\n@Module({\n  imports: [\n    ConfigModule.register({\n      isGlobal: true,\n      folder: './config',\n    }),\n  ],\n})\nexport class AppModule {}\n"),e.k0s()(),e.j41(852,"p"),e.EFF(853,"However, since "),e.j41(854,"code"),e.EFF(855,"isGlobal"),e.k0s(),e.EFF(856,' is declared as an "extra" property, it won\'t be available in the '),e.j41(857,"code"),e.EFF(858,"MODULE_OPTIONS_TOKEN"),e.k0s(),e.EFF(859," provider:"),e.k0s(),e.j41(860,"pre")(861,"code",14),e.EFF(862,'\n@Injectable()\nexport class ConfigService {\n  constructor(@Inject(MODULE_OPTIONS_TOKEN) private options: ConfigModuleOptions) {\n    // "options" object will not have the "isGlobal" property\n    // ...\n  }\n}\n'),e.k0s()(),e.j41(863,"h4",32)(864,"span"),e.EFF(865,"Extending auto-generated methods"),e.k0s()(),e.j41(866,"p"),e.EFF(867,"The auto-generated static methods ("),e.j41(868,"code"),e.EFF(869,"register"),e.k0s(),e.EFF(870,", "),e.j41(871,"code"),e.EFF(872,"registerAsync"),e.k0s(),e.EFF(873,", etc.) can be extended if needed, as follows:"),e.k0s(),e.j41(874,"pre")(875,"code",14),e.EFF(876,"\nimport { Module } from '@nestjs/common';\nimport { ConfigService } from './config.service';\nimport { ConfigurableModuleClass, ASYNC_OPTIONS_TYPE, OPTIONS_TYPE } from './config.module-definition';\n\n@Module({\n  providers: [ConfigService],\n  exports: [ConfigService],\n})\nexport class ConfigModule extends ConfigurableModuleClass {\n  static register(options: typeof OPTIONS_TYPE): DynamicModule {\n    return {\n      // your custom logic here\n      ...super.register(options),\n    };\n  }\n\n  static registerAsync(options: typeof ASYNC_OPTIONS_TYPE): DynamicModule {\n    return {\n      // your custom logic here\n      ...super.registerAsync(options),\n    };\n  }\n}\n"),e.k0s()(),e.j41(877,"p"),e.EFF(878,"Note the use of "),e.j41(879,"code"),e.EFF(880,"OPTIONS_TYPE"),e.k0s(),e.EFF(881," and "),e.j41(882,"code"),e.EFF(883,"ASYNC_OPTIONS_TYPE"),e.k0s(),e.EFF(884," types that must be exported from the module definition file:"),e.k0s(),e.j41(885,"pre")(886,"code",14),e.EFF(887,"\nexport const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN, OPTIONS_TYPE, ASYNC_OPTIONS_TYPE } = new ConfigurableModuleBuilder<ConfigModuleOptions>().build();\n"),e.k0s()()()),2&s){const a=e.sdS(656),r=e.sdS(722),i=e.sdS(775);e.R7$(569),e.Lme("HttpModule.register(","{"," baseUrl: 'someUrl' ","}",")"),e.R7$(3),e.Lme("HttpModule.register(","{"," baseUrl: 'somewhere else' ","}",")"),e.R7$(81),e.SpI(" ",e.i5U(654,19,"config.module-definition",a.isJsActive),"\n"),e.R7$(4),e.AVh("hide",a.isJsActive),e.R7$(3),e.AVh("hide",!a.isJsActive),e.R7$(59),e.SpI(" ",e.i5U(720,22,"config.module-definition",r.isJsActive),"\n"),e.R7$(4),e.AVh("hide",r.isJsActive),e.R7$(3),e.AVh("hide",!r.isJsActive),e.R7$(46),e.SpI(" ",e.i5U(773,25,"config.module-definition",i.isJsActive),"\n"),e.R7$(4),e.AVh("hide",i.isJsActive),e.R7$(3),e.AVh("hide",!i.isJsActive)}},dependencies:[E.O,l.a,b._,p.Wk,f.M],encapsulation:2,changeDetection:0})}return t})(),T=(()=>{class t extends F.y{static \u0275fac=(()=>{let o;return function(n){return(o||(o=e.xGo(t)))(n||t)}})();static \u0275cmp=e.VBU({type:t,selectors:[["app-lifecycle-events"]],features:[e.Vt3],decls:297,vars:12,consts:[["contentReference",""],["app7a814d14b4f6751b1f4b1cf200714c4ffbeab6db",""],["app04c5f2cf19f1bb9d02b0a94b8e3907822edcfa04",""],["appd06072fef96d308ece0df306f9cb76addac68191",""],[1,"content"],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/lifecycle-events.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","lifecycle-events"],["appAnchor","","id","lifecycle-sequence"],["src","/assets/lifecycle-events.png",1,"illustrative-image"],["appAnchor","","id","lifecycle-events-1"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/fundamentals/lifecycle-events#application-shutdown"],["href","fundamentals/lifecycle-events#application-shutdown"],[1,"warning"],[1,"info"],["appAnchor","","id","usage"],[1,"filename"],[1,"language-typescript"],["appAnchor","","id","asynchronous-initialization"],["appAnchor","","id","application-shutdown"],["rel","nofollow","target","_blank","href","https://kubernetes.io/"],["rel","nofollow","target","_blank","href","https://www.heroku.com/"],["rel","nofollow","target","_blank","href","https://nodejs.org/api/process.html#process_signal_events"],["rel","nofollow","target","_blank","href","https://docs.libuv.org/en/v1.x/signal.html"]],template:function(s,n){if(1&s&&(e.j41(0,"div",4,0)(2,"div",5)(3,"a",6),e.nrm(4,"i",7),e.k0s()(),e.j41(5,"h3",8),e.EFF(6,"Lifecycle Events"),e.k0s(),e.j41(7,"p"),e.EFF(8,"A Nest application, as well as every application element, has a lifecycle managed by Nest. Nest provides "),e.j41(9,"strong"),e.EFF(10,"lifecycle hooks"),e.k0s(),e.EFF(11," that give visibility into key lifecycle events, and the ability to act (run registered code on your modules, providers or controllers) when they occur."),e.k0s(),e.j41(12,"h4",9)(13,"span"),e.EFF(14,"Lifecycle sequence"),e.k0s()(),e.j41(15,"p"),e.EFF(16,"The following diagram depicts the sequence of key application lifecycle events, from the time the application is bootstrapped until the node process exits. We can divide the overall lifecycle into three phases: "),e.j41(17,"strong"),e.EFF(18,"initializing"),e.k0s(),e.EFF(19,", "),e.j41(20,"strong"),e.EFF(21,"running"),e.k0s(),e.EFF(22," and "),e.j41(23,"strong"),e.EFF(24,"terminating"),e.k0s(),e.EFF(25,". Using this lifecycle, you can plan for appropriate initialization of modules and services, manage active connections, and gracefully shutdown your application when it receives a termination signal."),e.k0s(),e.j41(26,"figure"),e.nrm(27,"img",10),e.k0s(),e.j41(28,"h4",11)(29,"span"),e.EFF(30,"Lifecycle events"),e.k0s()(),e.j41(31,"p"),e.EFF(32,"Lifecycle events happen during application bootstrapping and shutdown. Nest calls registered lifecycle hook methods on modules, providers and controllers at each of the following lifecycle events ("),e.j41(33,"strong"),e.EFF(34,"shutdown hooks"),e.k0s(),e.EFF(35," need to be enabled first, as described "),e.j41(36,"a",12),e.EFF(37,"below"),e.k0s(),e.EFF(38,"). As shown in the diagram above, Nest also calls the appropriate underlying methods to begin listening for connections, and to stop listening for connections."),e.k0s(),e.j41(39,"p"),e.EFF(40,"In the following table, "),e.j41(41,"code"),e.EFF(42,"onModuleDestroy"),e.k0s(),e.EFF(43,", "),e.j41(44,"code"),e.EFF(45,"beforeApplicationShutdown"),e.k0s(),e.EFF(46," and "),e.j41(47,"code"),e.EFF(48,"onApplicationShutdown"),e.k0s(),e.EFF(49," are only triggered if you explicitly call "),e.j41(50,"code"),e.EFF(51,"app.close()"),e.k0s(),e.EFF(52," or if the process receives a special system signal (such as SIGTERM) and you have correctly called "),e.j41(53,"code"),e.EFF(54,"enableShutdownHooks"),e.k0s(),e.EFF(55," at application bootstrap (see below "),e.j41(56,"strong"),e.EFF(57,"Application shutdown"),e.k0s(),e.EFF(58," part)."),e.k0s(),e.j41(59,"table")(60,"thead")(61,"tr")(62,"th"),e.EFF(63,"Lifecycle hook method"),e.k0s(),e.j41(64,"th"),e.EFF(65,"Lifecycle event triggering the hook method call"),e.k0s()()(),e.j41(66,"tbody")(67,"tr")(68,"td")(69,"code"),e.EFF(70,"onModuleInit()"),e.k0s()(),e.j41(71,"td"),e.EFF(72,"Called once the host module's dependencies have been resolved."),e.k0s()(),e.j41(73,"tr")(74,"td")(75,"code"),e.EFF(76,"onApplicationBootstrap()"),e.k0s()(),e.j41(77,"td"),e.EFF(78,"Called once all modules have been initialized, but before listening for connections."),e.k0s()(),e.j41(79,"tr")(80,"td")(81,"code"),e.EFF(82,"onModuleDestroy()"),e.k0s(),e.EFF(83,"*"),e.k0s(),e.j41(84,"td"),e.EFF(85,"Called after a termination signal (e.g., "),e.j41(86,"code"),e.EFF(87,"SIGTERM"),e.k0s(),e.EFF(88,") has been received."),e.k0s()(),e.j41(89,"tr")(90,"td")(91,"code"),e.EFF(92,"beforeApplicationShutdown()"),e.k0s(),e.EFF(93,"*"),e.k0s(),e.j41(94,"td"),e.EFF(95,"Called after all "),e.j41(96,"code"),e.EFF(97,"onModuleDestroy()"),e.k0s(),e.EFF(98," handlers have completed (Promises resolved or rejected);"),e.nrm(99,"br"),e.EFF(100,"once complete (Promises resolved or rejected), all existing connections will be closed ("),e.j41(101,"code"),e.EFF(102,"app.close()"),e.k0s(),e.EFF(103," called)."),e.k0s()(),e.j41(104,"tr")(105,"td")(106,"code"),e.EFF(107,"onApplicationShutdown()"),e.k0s(),e.EFF(108,"*"),e.k0s(),e.j41(109,"td"),e.EFF(110,"Called after connections close ("),e.j41(111,"code"),e.EFF(112,"app.close()"),e.k0s(),e.EFF(113," resolves)."),e.k0s()()()(),e.j41(114,"p"),e.EFF(115,"* For these events, if you're not calling "),e.j41(116,"code"),e.EFF(117,"app.close()"),e.k0s(),e.EFF(118," explicitly, you must opt-in to make them work with system signals such as "),e.j41(119,"code"),e.EFF(120,"SIGTERM"),e.k0s(),e.EFF(121,". See "),e.j41(122,"a",13),e.EFF(123,"Application shutdown"),e.k0s(),e.EFF(124," below."),e.k0s(),e.j41(125,"blockquote",14)(126,"strong"),e.EFF(127,"Warning"),e.k0s(),e.EFF(128," The lifecycle hooks listed above are not triggered for "),e.j41(129,"strong"),e.EFF(130,"request-scoped"),e.k0s(),e.EFF(131," classes. Request-scoped classes are not tied to the application lifecycle and their lifespan is unpredictable. They are exclusively created for each request and automatically garbage-collected after the response is sent.\n"),e.k0s(),e.j41(132,"blockquote",15)(133,"strong"),e.EFF(134,"Hint"),e.k0s(),e.EFF(135," Execution order of "),e.j41(136,"code"),e.EFF(137,"onModuleInit()"),e.k0s(),e.EFF(138," and "),e.j41(139,"code"),e.EFF(140,"onApplicationBootstrap()"),e.k0s(),e.EFF(141," directly depends on the order of module imports, awaiting the previous hook.\n"),e.k0s(),e.j41(142,"h4",16)(143,"span"),e.EFF(144,"Usage"),e.k0s()(),e.j41(145,"p"),e.EFF(146,"Each lifecycle hook is represented by an interface. Interfaces are technically optional because they do not exist after TypeScript compilation. Nonetheless, it's good practice to use them in order to benefit from strong typing and editor tooling. To register a lifecycle hook, implement the appropriate interface. For example, to register a method to be called during module initialization on a particular class (e.g., Controller, Provider or Module), implement the "),e.j41(147,"code"),e.EFF(148,"OnModuleInit"),e.k0s(),e.EFF(149," interface by supplying an "),e.j41(150,"code"),e.EFF(151,"onModuleInit()"),e.k0s(),e.EFF(152," method, as shown below:"),e.k0s(),e.j41(153,"span",17),e.nrm(154,"app-tabs",null,1),e.k0s(),e.j41(156,"pre")(157,"code",18),e.EFF(158,"\nimport { Injectable, OnModuleInit } from '@nestjs/common';\n\n@Injectable()\nexport class UsersService implements OnModuleInit {\n  onModuleInit() {\n    console.log(`The module has been initialized.`);\n  }\n}\n"),e.k0s()(),e.j41(159,"pre")(160,"code",18),e.EFF(161,"\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class UsersService {\n  onModuleInit() {\n    console.log(`The module has been initialized.`);\n  }\n}\n"),e.k0s()(),e.j41(162,"h4",19)(163,"span"),e.EFF(164,"Asynchronous initialization"),e.k0s()(),e.j41(165,"p"),e.EFF(166,"Both the "),e.j41(167,"code"),e.EFF(168,"OnModuleInit"),e.k0s(),e.EFF(169," and "),e.j41(170,"code"),e.EFF(171,"OnApplicationBootstrap"),e.k0s(),e.EFF(172," hooks allow you to defer the application initialization process (return a "),e.j41(173,"code"),e.EFF(174,"Promise"),e.k0s(),e.EFF(175," or mark the method as "),e.j41(176,"code"),e.EFF(177,"async"),e.k0s(),e.EFF(178," and "),e.j41(179,"code"),e.EFF(180,"await"),e.k0s(),e.EFF(181," an asynchronous method completion in the method body)."),e.k0s(),e.j41(182,"span",17),e.nrm(183,"app-tabs",null,2),e.k0s(),e.j41(185,"pre")(186,"code",18),e.EFF(187,"\nasync onModuleInit(): Promise<void> {\n  await this.fetch();\n}\n"),e.k0s()(),e.j41(188,"pre")(189,"code",18),e.EFF(190,"\nasync onModuleInit() {\n  await this.fetch();\n}\n"),e.k0s()(),e.j41(191,"h4",20)(192,"span"),e.EFF(193,"Application shutdown"),e.k0s()(),e.j41(194,"p"),e.EFF(195,"The "),e.j41(196,"code"),e.EFF(197,"onModuleDestroy()"),e.k0s(),e.EFF(198,", "),e.j41(199,"code"),e.EFF(200,"beforeApplicationShutdown()"),e.k0s(),e.EFF(201," and "),e.j41(202,"code"),e.EFF(203,"onApplicationShutdown()"),e.k0s(),e.EFF(204," hooks are called in the terminating phase (in response to an explicit call to "),e.j41(205,"code"),e.EFF(206,"app.close()"),e.k0s(),e.EFF(207," or upon receipt of system signals such as SIGTERM if opted-in). This feature is often used with "),e.j41(208,"a",21),e.EFF(209,"Kubernetes"),e.k0s(),e.EFF(210," to manage containers' lifecycles, by "),e.j41(211,"a",22),e.EFF(212,"Heroku"),e.k0s(),e.EFF(213," for dynos or similar services."),e.k0s(),e.j41(214,"p"),e.EFF(215,"Shutdown hook listeners consume system resources, so they are disabled by default. To use shutdown hooks, you "),e.j41(216,"strong"),e.EFF(217,"must enable listeners"),e.k0s(),e.EFF(218," by calling "),e.j41(219,"code"),e.EFF(220,"enableShutdownHooks()"),e.k0s(),e.EFF(221,":"),e.k0s(),e.j41(222,"pre")(223,"code",18),e.EFF(224,"\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n\n  // Starts listening for shutdown hooks\n  app.enableShutdownHooks();\n\n  await app.listen(process.env.PORT ?? 3000);\n}\nbootstrap();\n"),e.k0s()(),e.j41(225,"blockquote",14)(226,"strong"),e.EFF(227,"warning"),e.k0s(),e.EFF(228," Due to inherent platform limitations, NestJS has limited support for application shutdown hooks on Windows. You can expect "),e.j41(229,"code"),e.EFF(230,"SIGINT"),e.k0s(),e.EFF(231," to work, as well as "),e.j41(232,"code"),e.EFF(233,"SIGBREAK"),e.k0s(),e.EFF(234," and to some extent "),e.j41(235,"code"),e.EFF(236,"SIGHUP"),e.k0s(),e.EFF(237," - "),e.j41(238,"a",23),e.EFF(239,"read more"),e.k0s(),e.EFF(240,". However "),e.j41(241,"code"),e.EFF(242,"SIGTERM"),e.k0s(),e.EFF(243," will never work on Windows because killing a process in the task manager is unconditional, \"i.e., there's no way for an application to detect or prevent it\". Here's some "),e.j41(244,"a",24),e.EFF(245,"relevant documentation"),e.k0s(),e.EFF(246," from libuv to learn more about how "),e.j41(247,"code"),e.EFF(248,"SIGINT"),e.k0s(),e.EFF(249,", "),e.j41(250,"code"),e.EFF(251,"SIGBREAK"),e.k0s(),e.EFF(252," and others are handled on Windows. Also, see Node.js documentation of "),e.j41(253,"a",23),e.EFF(254,"Process Signal Events"),e.k0s()(),e.j41(255,"blockquote",15)(256,"strong"),e.EFF(257,"Info"),e.k0s(),e.j41(258,"code"),e.EFF(259,"enableShutdownHooks"),e.k0s(),e.EFF(260," consumes memory by starting listeners. In cases where you are running multiple Nest apps in a single Node process (e.g., when running parallel tests with Jest), Node may complain about excessive listener processes. For this reason, "),e.j41(261,"code"),e.EFF(262,"enableShutdownHooks"),e.k0s(),e.EFF(263," is not enabled by default. Be aware of this condition when you are running multiple instances in a single Node process.\n"),e.k0s(),e.j41(264,"p"),e.EFF(265,"When the application receives a termination signal it will call any registered "),e.j41(266,"code"),e.EFF(267,"onModuleDestroy()"),e.k0s(),e.EFF(268,", "),e.j41(269,"code"),e.EFF(270,"beforeApplicationShutdown()"),e.k0s(),e.EFF(271,", then "),e.j41(272,"code"),e.EFF(273,"onApplicationShutdown()"),e.k0s(),e.EFF(274," methods (in the sequence described above) with the corresponding signal as the first parameter. If a registered function awaits an asynchronous call (returns a promise), Nest will not continue in the sequence until the promise is resolved or rejected."),e.k0s(),e.j41(275,"span",17),e.nrm(276,"app-tabs",null,3),e.k0s(),e.j41(278,"pre")(279,"code",18),e.EFF(280,'\n@Injectable()\nclass UsersService implements OnApplicationShutdown {\n  onApplicationShutdown(signal: string) {\n    console.log(signal); // e.g. "SIGINT"\n  }\n}\n'),e.k0s()(),e.j41(281,"pre")(282,"code",18),e.EFF(283,'\n@Injectable()\nclass UsersService implements OnApplicationShutdown {\n  onApplicationShutdown(signal) {\n    console.log(signal); // e.g. "SIGINT"\n  }\n}\n'),e.k0s()(),e.j41(284,"blockquote",15)(285,"strong"),e.EFF(286,"Info"),e.k0s(),e.EFF(287," Calling "),e.j41(288,"code"),e.EFF(289,"app.close()"),e.k0s(),e.EFF(290," doesn't terminate the Node process but only triggers the "),e.j41(291,"code"),e.EFF(292,"onModuleDestroy()"),e.k0s(),e.EFF(293," and "),e.j41(294,"code"),e.EFF(295,"onApplicationShutdown()"),e.k0s(),e.EFF(296," hooks, so if there are some intervals, long-running background tasks, etc. the process won't be automatically terminated.\n"),e.k0s()()),2&s){const a=e.sdS(155),r=e.sdS(184),i=e.sdS(277);e.R7$(156),e.AVh("hide",a.isJsActive),e.R7$(3),e.AVh("hide",!a.isJsActive),e.R7$(26),e.AVh("hide",r.isJsActive),e.R7$(3),e.AVh("hide",!r.isJsActive),e.R7$(90),e.AVh("hide",i.isJsActive),e.R7$(3),e.AVh("hide",!i.isJsActive)}},dependencies:[E.O,l.a],encapsulation:2,changeDetection:0})}return t})(),M=(()=>{class t extends F.y{static \u0275fac=(()=>{let o;return function(n){return(o||(o=e.xGo(t)))(n||t)}})();static \u0275cmp=e.VBU({type:t,selectors:[["app-module-ref"]],features:[e.Vt3],decls:276,vars:58,consts:[["contentReference",""],["app18d091d7c2fa903472fabbaf06aa1c60a6546f38",""],["app98e31067a7c3f57cc36ee2cef23c168815bc44c8",""],["app559ffcb2a9200998c692d3becb2e4485821ceea1",""],["app20acfa97ec6f8396d0c736ebb58418b940530837",""],["app5a1c5b22557d15a801a07a541a81ddc6504e9b55",""],["app43866584d90a7d916dc617171c72bea43523ea13",""],["appcbc3b6260bd48c6a53df717e876eb02fc68e11c4",""],[1,"content"],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/module-reference.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","module-reference"],[1,"filename"],[1,"language-typescript"],[1,"info"],["appAnchor","","id","retrieving-instances"],[1,"warning"],["href","https://docs.nestjs.com/fundamentals/module-ref#resolving-scoped-providers"],["routerLink","/fundamentals/injection-scopes"],["appAnchor","","id","resolving-scoped-providers"],["appAnchor","","id","registering-request-provider"],["appAnchor","","id","getting-current-sub-tree"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/fundamentals/injection-scopes#request-provider"],["appAnchor","","id","instantiating-custom-classes-dynamically"]],template:function(s,n){if(1&s&&(e.j41(0,"div",8,0)(2,"div",9)(3,"a",10),e.nrm(4,"i",11),e.k0s()(),e.j41(5,"h3",12),e.EFF(6,"Module reference"),e.k0s(),e.j41(7,"p"),e.EFF(8,"Nest provides the "),e.j41(9,"code"),e.EFF(10,"ModuleRef"),e.k0s(),e.EFF(11," class to navigate the internal list of providers and obtain a reference to any provider using its injection token as a lookup key. The "),e.j41(12,"code"),e.EFF(13,"ModuleRef"),e.k0s(),e.EFF(14," class also provides a way to dynamically instantiate both static and scoped providers. "),e.j41(15,"code"),e.EFF(16,"ModuleRef"),e.k0s(),e.EFF(17," can be injected into a class in the normal way:"),e.k0s(),e.j41(18,"span",13),e.EFF(19),e.nI1(20,"extension"),e.nrm(21,"app-tabs",null,1),e.k0s(),e.j41(23,"pre")(24,"code",14),e.EFF(25,"\n@Injectable()\nexport class CatsService {\n  constructor(private moduleRef: ModuleRef) {}\n}\n"),e.k0s()(),e.j41(26,"pre")(27,"code",14),e.EFF(28,"\n@Injectable()\n@Dependencies(ModuleRef)\nexport class CatsService {\n  constructor(moduleRef) {\n    this.moduleRef = moduleRef;\n  }\n}\n"),e.k0s()(),e.j41(29,"blockquote",15)(30,"strong"),e.EFF(31,"Hint"),e.k0s(),e.EFF(32," The "),e.j41(33,"code"),e.EFF(34,"ModuleRef"),e.k0s(),e.EFF(35," class is imported from the "),e.j41(36,"code"),e.EFF(37,"@nestjs/core"),e.k0s(),e.EFF(38," package.\n"),e.k0s(),e.j41(39,"h4",16)(40,"span"),e.EFF(41,"Retrieving instances"),e.k0s()(),e.j41(42,"p"),e.EFF(43,"The "),e.j41(44,"code"),e.EFF(45,"ModuleRef"),e.k0s(),e.EFF(46," instance (hereafter we'll refer to it as the "),e.j41(47,"strong"),e.EFF(48,"module reference"),e.k0s(),e.EFF(49,") has a "),e.j41(50,"code"),e.EFF(51,"get()"),e.k0s(),e.EFF(52," method. By default, this method returns a provider, controller, or injectable (e.g., guard, interceptor, etc.) that was registered and has been instantiated in the "),e.j41(53,"em"),e.EFF(54,"current module"),e.k0s(),e.EFF(55," using its injection token/class name. If the instance is not found, an exception will be raised."),e.k0s(),e.j41(56,"span",13),e.EFF(57),e.nI1(58,"extension"),e.nrm(59,"app-tabs",null,2),e.k0s(),e.j41(61,"pre")(62,"code",14),e.EFF(63,"\n@Injectable()\nexport class CatsService implements OnModuleInit {\n  private service: Service;\n  constructor(private moduleRef: ModuleRef) {}\n\n  onModuleInit() {\n    this.service = this.moduleRef.get(Service);\n  }\n}\n"),e.k0s()(),e.j41(64,"pre")(65,"code",14),e.EFF(66,"\n@Injectable()\n@Dependencies(ModuleRef)\nexport class CatsService {\n  constructor(moduleRef) {\n    this.moduleRef = moduleRef;\n  }\n\n  onModuleInit() {\n    this.service = this.moduleRef.get(Service);\n  }\n}\n"),e.k0s()(),e.j41(67,"blockquote",17)(68,"strong"),e.EFF(69,"Warning"),e.k0s(),e.EFF(70," You can't retrieve scoped providers (transient or request-scoped) with the "),e.j41(71,"code"),e.EFF(72,"get()"),e.k0s(),e.EFF(73," method. Instead, use the technique described "),e.j41(74,"a",18),e.EFF(75,"below"),e.k0s(),e.EFF(76,". Learn how to control scopes "),e.j41(77,"a",19),e.EFF(78,"here"),e.k0s(),e.EFF(79,".\n"),e.k0s(),e.j41(80,"p"),e.EFF(81,"To retrieve a provider from the global context (for example, if the provider has been injected in a different module), pass the "),e.j41(82,"code"),e.EFF(83),e.k0s(),e.EFF(84," option as a second argument to "),e.j41(85,"code"),e.EFF(86,"get()"),e.k0s(),e.EFF(87,"."),e.k0s(),e.j41(88,"pre")(89,"code",14),e.EFF(90,"\nthis.moduleRef.get(Service, { strict: false });\n"),e.k0s()(),e.j41(91,"h4",20)(92,"span"),e.EFF(93,"Resolving scoped providers"),e.k0s()(),e.j41(94,"p"),e.EFF(95,"To dynamically resolve a scoped provider (transient or request-scoped), use the "),e.j41(96,"code"),e.EFF(97,"resolve()"),e.k0s(),e.EFF(98," method, passing the provider's injection token as an argument."),e.k0s(),e.j41(99,"span",13),e.EFF(100),e.nI1(101,"extension"),e.nrm(102,"app-tabs",null,3),e.k0s(),e.j41(104,"pre")(105,"code",14),e.EFF(106,"\n@Injectable()\nexport class CatsService implements OnModuleInit {\n  private transientService: TransientService;\n  constructor(private moduleRef: ModuleRef) {}\n\n  async onModuleInit() {\n    this.transientService = await this.moduleRef.resolve(TransientService);\n  }\n}\n"),e.k0s()(),e.j41(107,"pre")(108,"code",14),e.EFF(109,"\n@Injectable()\n@Dependencies(ModuleRef)\nexport class CatsService {\n  constructor(moduleRef) {\n    this.moduleRef = moduleRef;\n  }\n\n  async onModuleInit() {\n    this.transientService = await this.moduleRef.resolve(TransientService);\n  }\n}\n"),e.k0s()(),e.j41(110,"p"),e.EFF(111,"The "),e.j41(112,"code"),e.EFF(113,"resolve()"),e.k0s(),e.EFF(114," method returns a unique instance of the provider, from its own "),e.j41(115,"strong"),e.EFF(116,"DI container sub-tree"),e.k0s(),e.EFF(117,". Each sub-tree has a unique "),e.j41(118,"strong"),e.EFF(119,"context identifier"),e.k0s(),e.EFF(120,". Thus, if you call this method more than once and compare instance references, you will see that they are not equal."),e.k0s(),e.j41(121,"span",13),e.EFF(122),e.nI1(123,"extension"),e.nrm(124,"app-tabs",null,4),e.k0s(),e.j41(126,"pre")(127,"code",14),e.EFF(128,"\n@Injectable()\nexport class CatsService implements OnModuleInit {\n  constructor(private moduleRef: ModuleRef) {}\n\n  async onModuleInit() {\n    const transientServices = await Promise.all([\n      this.moduleRef.resolve(TransientService),\n      this.moduleRef.resolve(TransientService),\n    ]);\n    console.log(transientServices[0] === transientServices[1]); // false\n  }\n}\n"),e.k0s()(),e.j41(129,"pre")(130,"code",14),e.EFF(131,"\n@Injectable()\n@Dependencies(ModuleRef)\nexport class CatsService {\n  constructor(moduleRef) {\n    this.moduleRef = moduleRef;\n  }\n\n  async onModuleInit() {\n    const transientServices = await Promise.all([\n      this.moduleRef.resolve(TransientService),\n      this.moduleRef.resolve(TransientService),\n    ]);\n    console.log(transientServices[0] === transientServices[1]); // false\n  }\n}\n"),e.k0s()(),e.j41(132,"p"),e.EFF(133,"To generate a single instance across multiple "),e.j41(134,"code"),e.EFF(135,"resolve()"),e.k0s(),e.EFF(136," calls, and ensure they share the same generated DI container sub-tree, you can pass a context identifier to the "),e.j41(137,"code"),e.EFF(138,"resolve()"),e.k0s(),e.EFF(139," method. Use the "),e.j41(140,"code"),e.EFF(141,"ContextIdFactory"),e.k0s(),e.EFF(142," class to generate a context identifier. This class provides a "),e.j41(143,"code"),e.EFF(144,"create()"),e.k0s(),e.EFF(145," method that returns an appropriate unique identifier."),e.k0s(),e.j41(146,"span",13),e.EFF(147),e.nI1(148,"extension"),e.nrm(149,"app-tabs",null,5),e.k0s(),e.j41(151,"pre")(152,"code",14),e.EFF(153,"\n@Injectable()\nexport class CatsService implements OnModuleInit {\n  constructor(private moduleRef: ModuleRef) {}\n\n  async onModuleInit() {\n    const contextId = ContextIdFactory.create();\n    const transientServices = await Promise.all([\n      this.moduleRef.resolve(TransientService, contextId),\n      this.moduleRef.resolve(TransientService, contextId),\n    ]);\n    console.log(transientServices[0] === transientServices[1]); // true\n  }\n}\n"),e.k0s()(),e.j41(154,"pre")(155,"code",14),e.EFF(156,"\n@Injectable()\n@Dependencies(ModuleRef)\nexport class CatsService {\n  constructor(moduleRef) {\n    this.moduleRef = moduleRef;\n  }\n\n  async onModuleInit() {\n    const contextId = ContextIdFactory.create();\n    const transientServices = await Promise.all([\n      this.moduleRef.resolve(TransientService, contextId),\n      this.moduleRef.resolve(TransientService, contextId),\n    ]);\n    console.log(transientServices[0] === transientServices[1]); // true\n  }\n}\n"),e.k0s()(),e.j41(157,"blockquote",15)(158,"strong"),e.EFF(159,"Hint"),e.k0s(),e.EFF(160," The "),e.j41(161,"code"),e.EFF(162,"ContextIdFactory"),e.k0s(),e.EFF(163," class is imported from the "),e.j41(164,"code"),e.EFF(165,"@nestjs/core"),e.k0s(),e.EFF(166," package.\n"),e.k0s(),e.j41(167,"h4",21)(168,"span"),e.EFF(169,"Registering "),e.j41(170,"code"),e.EFF(171,"REQUEST"),e.k0s(),e.EFF(172," provider"),e.k0s()(),e.j41(173,"p"),e.EFF(174,"Manually generated context identifiers (with "),e.j41(175,"code"),e.EFF(176,"ContextIdFactory.create()"),e.k0s(),e.EFF(177,") represent DI sub-trees in which "),e.j41(178,"code"),e.EFF(179,"REQUEST"),e.k0s(),e.EFF(180," provider is "),e.j41(181,"code"),e.EFF(182,"undefined"),e.k0s(),e.EFF(183," as they are not instantiated and managed by the Nest dependency injection system."),e.k0s(),e.j41(184,"p"),e.EFF(185,"To register a custom "),e.j41(186,"code"),e.EFF(187,"REQUEST"),e.k0s(),e.EFF(188," object for a manually created DI sub-tree, use the "),e.j41(189,"code"),e.EFF(190,"ModuleRef#registerRequestByContextId()"),e.k0s(),e.EFF(191," method, as follows:"),e.k0s(),e.j41(192,"pre")(193,"code",14),e.EFF(194,"\nconst contextId = ContextIdFactory.create();\nthis.moduleRef.registerRequestByContextId(/* YOUR_REQUEST_OBJECT */, contextId);\n"),e.k0s()(),e.j41(195,"h4",22)(196,"span"),e.EFF(197,"Getting current sub-tree"),e.k0s()(),e.j41(198,"p"),e.EFF(199,"Occasionally, you may want to resolve an instance of a request-scoped provider within a "),e.j41(200,"strong"),e.EFF(201,"request context"),e.k0s(),e.EFF(202,". Let's say that "),e.j41(203,"code"),e.EFF(204,"CatsService"),e.k0s(),e.EFF(205," is request-scoped and you want to resolve the "),e.j41(206,"code"),e.EFF(207,"CatsRepository"),e.k0s(),e.EFF(208," instance which is also marked as a request-scoped provider. In order to share the same DI container sub-tree, you must obtain the current context identifier instead of generating a new one (e.g., with the "),e.j41(209,"code"),e.EFF(210,"ContextIdFactory.create()"),e.k0s(),e.EFF(211," function, as shown above). To obtain the current context identifier, start by injecting the request object using "),e.j41(212,"code"),e.EFF(213,"@Inject()"),e.k0s(),e.EFF(214," decorator."),e.k0s(),e.j41(215,"span",13),e.EFF(216),e.nI1(217,"extension"),e.nrm(218,"app-tabs",null,6),e.k0s(),e.j41(220,"pre")(221,"code",14),e.EFF(222,"\n@Injectable()\nexport class CatsService {\n  constructor(\n    @Inject(REQUEST) private request: Record<string, unknown>,\n  ) {}\n}\n"),e.k0s()(),e.j41(223,"pre")(224,"code",14),e.EFF(225,"\n@Injectable()\n@Dependencies(REQUEST)\nexport class CatsService {\n  constructor(request) {\n    this.request = request;\n  }\n}\n"),e.k0s()(),e.j41(226,"blockquote",15)(227,"strong"),e.EFF(228,"Hint"),e.k0s(),e.EFF(229," Learn more about the request provider "),e.j41(230,"a",23),e.EFF(231,"here"),e.k0s(),e.EFF(232,".\n"),e.k0s(),e.j41(233,"p"),e.EFF(234,"Now, use the "),e.j41(235,"code"),e.EFF(236,"getByRequest()"),e.k0s(),e.EFF(237," method of the "),e.j41(238,"code"),e.EFF(239,"ContextIdFactory"),e.k0s(),e.EFF(240," class to create a context id based on the request object, and pass this to the "),e.j41(241,"code"),e.EFF(242,"resolve()"),e.k0s(),e.EFF(243," call:"),e.k0s(),e.j41(244,"pre")(245,"code",14),e.EFF(246,"\nconst contextId = ContextIdFactory.getByRequest(this.request);\nconst catsRepository = await this.moduleRef.resolve(CatsRepository, contextId);\n"),e.k0s()(),e.j41(247,"h4",24)(248,"span"),e.EFF(249,"Instantiating custom classes dynamically"),e.k0s()(),e.j41(250,"p"),e.EFF(251,"To dynamically instantiate a class that "),e.j41(252,"strong"),e.EFF(253,"wasn't previously registered"),e.k0s(),e.EFF(254," as a "),e.j41(255,"strong"),e.EFF(256,"provider"),e.k0s(),e.EFF(257,", use the module reference's "),e.j41(258,"code"),e.EFF(259,"create()"),e.k0s(),e.EFF(260," method."),e.k0s(),e.j41(261,"span",13),e.EFF(262),e.nI1(263,"extension"),e.nrm(264,"app-tabs",null,7),e.k0s(),e.j41(266,"pre")(267,"code",14),e.EFF(268,"\n@Injectable()\nexport class CatsService implements OnModuleInit {\n  private catsFactory: CatsFactory;\n  constructor(private moduleRef: ModuleRef) {}\n\n  async onModuleInit() {\n    this.catsFactory = await this.moduleRef.create(CatsFactory);\n  }\n}\n"),e.k0s()(),e.j41(269,"pre")(270,"code",14),e.EFF(271,"\n@Injectable()\n@Dependencies(ModuleRef)\nexport class CatsService {\n  constructor(moduleRef) {\n    this.moduleRef = moduleRef;\n  }\n\n  async onModuleInit() {\n    this.catsFactory = await this.moduleRef.create(CatsFactory);\n  }\n}\n"),e.k0s()(),e.j41(272,"p"),e.EFF(273,"This technique enables you to conditionally instantiate different classes outside of the framework container."),e.k0s(),e.j41(274,"p"),e.nrm(275,"app-banner-devtools"),e.k0s()()),2&s){const a=e.sdS(22),r=e.sdS(60),i=e.sdS(103),d=e.sdS(125),m=e.sdS(150),u=e.sdS(219),h=e.sdS(265);e.R7$(19),e.SpI(" ",e.i5U(20,37,"cats.service",a.isJsActive),"\n"),e.R7$(4),e.AVh("hide",a.isJsActive),e.R7$(3),e.AVh("hide",!a.isJsActive),e.R7$(31),e.SpI(" ",e.i5U(58,40,"cats.service",r.isJsActive),"\n"),e.R7$(4),e.AVh("hide",r.isJsActive),e.R7$(3),e.AVh("hide",!r.isJsActive),e.R7$(19),e.Lme("","{"," strict: false ","}",""),e.R7$(17),e.SpI(" ",e.i5U(101,43,"cats.service",i.isJsActive),"\n"),e.R7$(4),e.AVh("hide",i.isJsActive),e.R7$(3),e.AVh("hide",!i.isJsActive),e.R7$(15),e.SpI(" ",e.i5U(123,46,"cats.service",d.isJsActive),"\n"),e.R7$(4),e.AVh("hide",d.isJsActive),e.R7$(3),e.AVh("hide",!d.isJsActive),e.R7$(18),e.SpI(" ",e.i5U(148,49,"cats.service",m.isJsActive),"\n"),e.R7$(4),e.AVh("hide",m.isJsActive),e.R7$(3),e.AVh("hide",!m.isJsActive),e.R7$(62),e.SpI(" ",e.i5U(217,52,"cats.service",u.isJsActive),"\n"),e.R7$(4),e.AVh("hide",u.isJsActive),e.R7$(3),e.AVh("hide",!u.isJsActive),e.R7$(39),e.SpI(" ",e.i5U(263,55,"cats.service",h.isJsActive),"\n"),e.R7$(4),e.AVh("hide",h.isJsActive),e.R7$(3),e.AVh("hide",!h.isJsActive)}},dependencies:[E.O,l.a,b._,p.Wk,f.M],encapsulation:2,changeDetection:0})}return t})();var R=c(8149);const N=[{path:"dynamic-modules",component:I,data:{title:"Dynamic modules"}},{path:"dependency-injection",redirectTo:"custom-providers"},{path:"custom-providers",component:A,data:{title:"Custom providers"}},{path:"platform-agnosticism",component:(()=>{class t extends F.y{static \u0275fac=(()=>{let o;return function(n){return(o||(o=e.xGo(t)))(n||t)}})();static \u0275cmp=e.VBU({type:t,selectors:[["app-platform-agnosticism"]],features:[e.Vt3],decls:41,vars:0,consts:[["contentReference",""],[1,"content"],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/platform-agnosticism.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","platform-agnosticism"],["appAnchor","","id","build-once-use-everywhere"],["routerLink","/microservices/basics"],["routerLink","/websockets/gateways"],["routerLink","/graphql/quick-start"],["routerLink","/application-context"]],template:function(s,n){1&s&&(e.j41(0,"div",1,0)(2,"div",2)(3,"a",3),e.nrm(4,"i",4),e.k0s()(),e.j41(5,"h3",5),e.EFF(6,"Platform agnosticism"),e.k0s(),e.j41(7,"p"),e.EFF(8,"Nest is a platform-agnostic framework. This means you can develop "),e.j41(9,"strong"),e.EFF(10,"reusable logical parts"),e.k0s(),e.EFF(11," that can be used across different types of applications. For example, most components can be re-used without change across different underlying HTTP server frameworks (e.g., Express and Fastify), and even across different "),e.j41(12,"em"),e.EFF(13,"types"),e.k0s(),e.EFF(14," of applications (e.g., HTTP server frameworks, Microservices with different transport layers, and Web Sockets)."),e.k0s(),e.j41(15,"h4",6)(16,"span"),e.EFF(17,"Build once, use everywhere"),e.k0s()(),e.j41(18,"p"),e.EFF(19,"The "),e.j41(20,"strong"),e.EFF(21,"Overview"),e.k0s(),e.EFF(22," section of the documentation primarily shows coding techniques using HTTP server frameworks (e.g., apps providing a REST API or providing an MVC-style server-side rendered app). However, all those building blocks can be used on top of different transport layers ("),e.j41(23,"a",7),e.EFF(24,"microservices"),e.k0s(),e.EFF(25," or "),e.j41(26,"a",8),e.EFF(27,"websockets"),e.k0s(),e.EFF(28,")."),e.k0s(),e.j41(29,"p"),e.EFF(30,"Furthermore, Nest comes with a dedicated "),e.j41(31,"a",9),e.EFF(32,"GraphQL"),e.k0s(),e.EFF(33," module. You can use GraphQL as your API layer interchangeably with providing a REST API."),e.k0s(),e.j41(34,"p"),e.EFF(35,"In addition, the "),e.j41(36,"a",10),e.EFF(37,"application context"),e.k0s(),e.EFF(38," feature helps to create any kind of Node.js application - including things like CRON jobs and CLI apps - on top of Nest."),e.k0s(),e.j41(39,"p"),e.EFF(40,"Nest aspires to be a full-fledged platform for Node.js apps that brings a higher-level of modularity and reusability to your applications. Build once, use everywhere!"),e.k0s()())},dependencies:[l.a,p.Wk],encapsulation:2,changeDetection:0})}return t})(),data:{title:"Platform agnosticism"}},{path:"async-components",redirectTo:"async-providers"},{path:"async-providers",component:x,data:{title:"Async providers"}},{path:"module-ref",component:M,data:{title:"Module reference"}},{path:"lazy-loading-modules",component:(()=>{class t extends F.y{static \u0275fac=(()=>{let o;return function(n){return(o||(o=e.xGo(t)))(n||t)}})();static \u0275cmp=e.VBU({type:t,selectors:[["app-lazy-loading"]],features:[e.Vt3],decls:223,vars:8,consts:[["contentReference",""],["app283f1d20a769fcdfefeab223b881dd42d8e4afa0",""],[1,"content"],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/lazy-loading-modules.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","lazy-loading-modules"],[1,"info"],["rel","nofollow","target","_blank","href","https://angular.dev/"],["rel","nofollow","target","_blank","href","https://angular.dev/guide/ngmodules/lazy-loading#lazy-loading-basics"],[1,"warning"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/fundamentals/lifecycle-events"],["appAnchor","","id","getting-started"],[1,"filename"],[1,"language-typescript"],[1,"language-bash"],["routerLink","/fundamentals/module-ref"],[1,"language-json"],["rel","nofollow","target","_blank","href","https://webpack.js.org/guides/code-splitting/"],["appAnchor","","id","lazy-loading-controllers-gateways-and-resolvers"],[1,"error"],["routerLink","/graphql/resolvers"],["routerLink","/websockets/gateways"],["appAnchor","","id","common-use-cases"]],template:function(s,n){if(1&s&&(e.j41(0,"div",2,0)(2,"div",3)(3,"a",4),e.nrm(4,"i",5),e.k0s()(),e.j41(5,"h3",6),e.EFF(6,"Lazy loading modules"),e.k0s(),e.j41(7,"p"),e.EFF(8,"By default, modules are eagerly loaded, which means that as soon as the application loads, so do all the modules, whether or not they are immediately necessary. While this is fine for most applications, it may become a bottleneck for apps/workers running in the "),e.j41(9,"strong"),e.EFF(10,"serverless environment"),e.k0s(),e.EFF(11,', where the startup latency ("cold start") is crucial.'),e.k0s(),e.j41(12,"p"),e.EFF(13,'Lazy loading can help decrease bootstrap time by loading only modules required by the specific serverless function invocation. In addition, you could also load other modules asynchronously once the serverless function is "warm" to speed-up the bootstrap time for subsequent calls even further (deferred modules registration).'),e.k0s(),e.j41(14,"blockquote",7)(15,"strong"),e.EFF(16,"Hint"),e.k0s(),e.EFF(17," If you're familiar with the "),e.j41(18,"strong")(19,"a",8),e.EFF(20,"Angular"),e.k0s()(),e.EFF(21,' framework, you might have seen the "'),e.j41(22,"a",9),e.EFF(23,"lazy-loading modules"),e.k0s(),e.EFF(24,'" term before. Be aware that this technique is '),e.j41(25,"strong"),e.EFF(26,"functionally different"),e.k0s(),e.EFF(27," in Nest and so think about this as an entirely different feature that shares similar naming conventions.\n"),e.k0s(),e.j41(28,"blockquote",10)(29,"strong"),e.EFF(30,"Warning"),e.k0s(),e.EFF(31," Do note that "),e.j41(32,"a",11),e.EFF(33,"lifecycle hooks methods"),e.k0s(),e.EFF(34," are not invoked in lazy loaded modules and services.\n"),e.k0s(),e.j41(35,"h4",12)(36,"span"),e.EFF(37,"Getting started"),e.k0s()(),e.j41(38,"p"),e.EFF(39,"To load modules on-demand, Nest provides the "),e.j41(40,"code"),e.EFF(41,"LazyModuleLoader"),e.k0s(),e.EFF(42," class that can be injected into a class in the normal way:"),e.k0s(),e.j41(43,"span",13),e.EFF(44),e.nI1(45,"extension"),e.nrm(46,"app-tabs",null,1),e.k0s(),e.j41(48,"pre")(49,"code",14),e.EFF(50,"\n@Injectable()\nexport class CatsService {\n  constructor(private lazyModuleLoader: LazyModuleLoader) {}\n}\n"),e.k0s()(),e.j41(51,"pre")(52,"code",14),e.EFF(53,"\n@Injectable()\n@Dependencies(LazyModuleLoader)\nexport class CatsService {\n  constructor(lazyModuleLoader) {\n    this.lazyModuleLoader = lazyModuleLoader;\n  }\n}\n"),e.k0s()(),e.j41(54,"blockquote",7)(55,"strong"),e.EFF(56,"Hint"),e.k0s(),e.EFF(57," The "),e.j41(58,"code"),e.EFF(59,"LazyModuleLoader"),e.k0s(),e.EFF(60," class is imported from the "),e.j41(61,"code"),e.EFF(62,"@nestjs/core"),e.k0s(),e.EFF(63," package.\n"),e.k0s(),e.j41(64,"p"),e.EFF(65,"Alternatively, you can obtain a reference to the "),e.j41(66,"code"),e.EFF(67,"LazyModuleLoader"),e.k0s(),e.EFF(68," provider from within your application bootstrap file ("),e.j41(69,"code"),e.EFF(70,"main.ts"),e.k0s(),e.EFF(71,"), as follows:"),e.k0s(),e.j41(72,"pre")(73,"code",14),e.EFF(74,'\n// "app" represents a Nest application instance\nconst lazyModuleLoader = app.get(LazyModuleLoader);\n'),e.k0s()(),e.j41(75,"p"),e.EFF(76,"With this in place, you can now load any module using the following construction:"),e.k0s(),e.j41(77,"pre")(78,"code",14),e.EFF(79,"\nconst { LazyModule } = await import('./lazy.module');\nconst moduleRef = await this.lazyModuleLoader.load(() => LazyModule);\n"),e.k0s()(),e.j41(80,"blockquote",7)(81,"strong"),e.EFF(82,"Hint"),e.k0s(),e.EFF(83,' "Lazy loaded" modules are '),e.j41(84,"strong"),e.EFF(85,"cached"),e.k0s(),e.EFF(86," upon the first "),e.j41(87,"code"),e.EFF(88,"LazyModuleLoader#load"),e.k0s(),e.EFF(89," method invocation. That means, each consecutive attempt to load "),e.j41(90,"code"),e.EFF(91,"LazyModule"),e.k0s(),e.EFF(92," will be "),e.j41(93,"strong"),e.EFF(94,"very fast"),e.k0s(),e.EFF(95," and will return a cached instance, instead of loading the module again.\n"),e.j41(96,"pre")(97,"code",15),e.EFF(98,'\nLoad "LazyModule" attempt: 1\ntime: 2.379ms\nLoad "LazyModule" attempt: 2\ntime: 0.294ms\nLoad "LazyModule" attempt: 3\ntime: 0.303ms\n'),e.k0s()(),e.j41(99,"p"),e.EFF(100,'Also, "lazy loaded" modules share the same modules graph as those eagerly loaded on the application bootstrap as well as any other lazy modules registered later in your app.'),e.k0s()(),e.j41(101,"p"),e.EFF(102,"Where "),e.j41(103,"code"),e.EFF(104,"lazy.module.ts"),e.k0s(),e.EFF(105," is a TypeScript file that exports a "),e.j41(106,"strong"),e.EFF(107,"regular Nest module"),e.k0s(),e.EFF(108," (no extra changes are required)."),e.k0s(),e.j41(109,"p"),e.EFF(110,"The "),e.j41(111,"code"),e.EFF(112,"LazyModuleLoader#load"),e.k0s(),e.EFF(113," method returns the "),e.j41(114,"a",16),e.EFF(115,"module reference"),e.k0s(),e.EFF(116," (of "),e.j41(117,"code"),e.EFF(118,"LazyModule"),e.k0s(),e.EFF(119,") that lets you navigate the internal list of providers and obtain a reference to any provider using its injection token as a lookup key."),e.k0s(),e.j41(120,"p"),e.EFF(121,"For example, let's say we have a "),e.j41(122,"code"),e.EFF(123,"LazyModule"),e.k0s(),e.EFF(124," with the following definition:"),e.k0s(),e.j41(125,"pre")(126,"code",14),e.EFF(127,"\n@Module({\n  providers: [LazyService],\n  exports: [LazyService],\n})\nexport class LazyModule {}\n"),e.k0s()(),e.j41(128,"blockquote",7)(129,"strong"),e.EFF(130,"Hint"),e.k0s(),e.EFF(131," Lazy loaded modules cannot be registered as "),e.j41(132,"strong"),e.EFF(133,"global modules"),e.k0s(),e.EFF(134," as it simply makes no sense (since they are registered lazily, on-demand when all the statically registered modules have been already instantiated). Likewise, registered "),e.j41(135,"strong"),e.EFF(136,"global enhancers"),e.k0s(),e.EFF(137," (guards/interceptors/etc.) "),e.j41(138,"strong"),e.EFF(139,"will not work"),e.k0s(),e.EFF(140," properly either.\n"),e.k0s(),e.j41(141,"p"),e.EFF(142,"With this, we could obtain a reference to the "),e.j41(143,"code"),e.EFF(144,"LazyService"),e.k0s(),e.EFF(145," provider, as follows:"),e.k0s(),e.j41(146,"pre")(147,"code",14),e.EFF(148,"\nconst { LazyModule } = await import('./lazy.module');\nconst moduleRef = await this.lazyModuleLoader.load(() => LazyModule);\n\nconst { LazyService } = await import('./lazy.service');\nconst lazyService = moduleRef.get(LazyService);\n"),e.k0s()(),e.j41(149,"blockquote",10)(150,"strong"),e.EFF(151,"Warning"),e.k0s(),e.EFF(152," If you use "),e.j41(153,"strong"),e.EFF(154,"Webpack"),e.k0s(),e.EFF(155,", make sure to update your "),e.j41(156,"code"),e.EFF(157,"tsconfig.json"),e.k0s(),e.EFF(158," file - setting "),e.j41(159,"code"),e.EFF(160,"compilerOptions.module"),e.k0s(),e.EFF(161," to "),e.j41(162,"code"),e.EFF(163,'"esnext"'),e.k0s(),e.EFF(164," and adding "),e.j41(165,"code"),e.EFF(166,"compilerOptions.moduleResolution"),e.k0s(),e.EFF(167," property with "),e.j41(168,"code"),e.EFF(169,'"node"'),e.k0s(),e.EFF(170," as a value:\n"),e.j41(171,"pre")(172,"code",17),e.EFF(173,'\n{\n  "compilerOptions": {\n    "module": "esnext",\n    "moduleResolution": "node",\n    ...\n  }\n}\n'),e.k0s()(),e.j41(174,"p"),e.EFF(175,"With these options set up, you'll be able to leverage the "),e.j41(176,"a",18),e.EFF(177,"code splitting"),e.k0s(),e.EFF(178," feature."),e.k0s()(),e.j41(179,"h4",19)(180,"span"),e.EFF(181,"Lazy loading controllers, gateways, and resolvers"),e.k0s()(),e.j41(182,"p"),e.EFF(183,"Since controllers (or resolvers in GraphQL applications) in Nest represent sets of routes/paths/topics (or queries/mutations), you "),e.j41(184,"strong"),e.EFF(185,"cannot lazy load them"),e.k0s(),e.EFF(186," using the "),e.j41(187,"code"),e.EFF(188,"LazyModuleLoader"),e.k0s(),e.EFF(189," class."),e.k0s(),e.j41(190,"blockquote",20)(191,"strong"),e.EFF(192,"Warning"),e.k0s(),e.EFF(193," Controllers, "),e.j41(194,"a",21),e.EFF(195,"resolvers"),e.k0s(),e.EFF(196,", and "),e.j41(197,"a",22),e.EFF(198,"gateways"),e.k0s(),e.EFF(199," registered inside lazy loaded modules will not behave as expected. Similarly, you cannot register middleware functions (by implementing the "),e.j41(200,"code"),e.EFF(201,"MiddlewareConsumer"),e.k0s(),e.EFF(202," interface) on-demand.\n"),e.k0s(),e.j41(203,"p"),e.EFF(204,"For example, let's say you're building a REST API (HTTP application) with a Fastify driver under the hood (using the "),e.j41(205,"code"),e.EFF(206,"@nestjs/platform-fastify"),e.k0s(),e.EFF(207," package). Fastify does not let you register routes after the application is ready/successfully listening to messages. That means even if we analyzed route mappings registered in the module's controllers, all lazy loaded routes wouldn't be accessible since there is no way to register them at runtime."),e.k0s(),e.j41(208,"p"),e.EFF(209,"Likewise, some transport strategies we provide as part of the "),e.j41(210,"code"),e.EFF(211,"@nestjs/microservices"),e.k0s(),e.EFF(212," package (including Kafka, gRPC, or RabbitMQ) require to subscribe/listen to specific topics/channels before the connection is established. Once your application starts listening to messages, the framework would not be able to subscribe/listen to new topics."),e.k0s(),e.j41(213,"p"),e.EFF(214,"Lastly, the "),e.j41(215,"code"),e.EFF(216,"@nestjs/graphql"),e.k0s(),e.EFF(217," package with the code first approach enabled automatically generates the GraphQL schema on-the-fly based on the metadata. That means, it requires all classes to be loaded beforehand. Otherwise, it would not be doable to create the appropriate, valid schema."),e.k0s(),e.j41(218,"h4",23)(219,"span"),e.EFF(220,"Common use-cases"),e.k0s()(),e.j41(221,"p"),e.EFF(222,"Most commonly, you will see lazy loaded modules in situations when your worker/cron job/lambda & serverless function/webhook must trigger different services (different logic) based on the input arguments (route path/date/query parameters, etc.). On the other hand, lazy loading modules may not make too much sense for monolithic applications, where the startup time is rather irrelevant."),e.k0s()()),2&s){const a=e.sdS(47);e.R7$(44),e.SpI(" ",e.i5U(45,5,"cats.service",a.isJsActive),"\n"),e.R7$(4),e.AVh("hide",a.isJsActive),e.R7$(3),e.AVh("hide",!a.isJsActive)}},dependencies:[E.O,l.a,p.Wk,f.M],encapsulation:2,changeDetection:0})}return t})(),data:{title:"Lazy loading modules"}},{path:"unit-testing",redirectTo:"testing"},{path:"e2e-testing",redirectTo:"testing"},{path:"testing",component:(()=>{class t extends F.y{static \u0275fac=(()=>{let o;return function(n){return(o||(o=e.xGo(t)))(n||t)}})();static \u0275cmp=e.VBU({type:t,selectors:[["app-unit-testing"]],features:[e.Vt3],decls:535,vars:24,consts:[["contentReference",""],["app6888cf23924fb42efb6cae485aab67b713aba8e5",""],["appbf0fa5e593e7e54785bda51767f36db41d597a5e",""],["appc95e25cd8cc2f9eb0957a389a4b509a3fb7b9972",""],[1,"content"],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/unit-testing.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","testing"],["rel","nofollow","target","_blank","href","https://github.com/facebook/jest"],["rel","nofollow","target","_blank","href","https://github.com/visionmedia/supertest"],["appAnchor","","id","installation"],[1,"language-bash"],["appAnchor","","id","unit-testing"],[1,"filename"],[1,"language-typescript"],[1,"info"],["appAnchor","","id","testing-utilities"],["routerLink","/fundamentals/module-ref"],[1,"warning"],["routerLink","/fundamentals/custom-providers"],["appAnchor","","id","auto-mocking"],["rel","nofollow","target","_blank","href","https://www.npmjs.com/package/jest-mock"],["rel","nofollow","target","_blank","href","https://github.com/golevelup/nestjs/tree/master/packages/testing"],["appAnchor","","id","end-to-end-testing"],["routerLink","/techniques/performance"],[1,"language-ts"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/fundamentals/custom-providers"],["rel","nofollow","target","_blank","href","https://en.wikipedia.org/wiki/Fluent_interface"],["href","/fundamentals/module-ref"],["appAnchor","","id","overriding-globally-registered-enhancers"],["appAnchor","","id","testing-request-scoped-instances"],["routerLink","/fundamentals/injection-scopes"],["href","https://docs.nestjs.com/fundamentals/module-ref#resolving-scoped-providers"]],template:function(s,n){if(1&s&&(e.j41(0,"div",4,0)(2,"div",5)(3,"a",6),e.nrm(4,"i",7),e.k0s()(),e.j41(5,"h3",8),e.EFF(6,"Testing"),e.k0s(),e.j41(7,"p"),e.EFF(8,"Automated testing is considered an essential part of any serious software development effort. Automation makes it easy to repeat individual tests or test suites quickly and easily during development. This helps ensure that releases meet quality and performance goals. Automation helps increase coverage and provides a faster feedback loop to developers. Automation both increases the productivity of individual developers and ensures that tests are run at critical development lifecycle junctures, such as source code control check-in, feature integration, and version release."),e.k0s(),e.j41(9,"p"),e.EFF(10,"Such tests often span a variety of types, including unit tests, end-to-end (e2e) tests, integration tests, and so on. While the benefits are unquestionable, it can be tedious to set them up. Nest strives to promote development best practices, including effective testing, so it includes features such as the following to help developers and teams build and automate tests. Nest:"),e.k0s(),e.j41(11,"ul")(12,"li"),e.EFF(13,"automatically scaffolds default unit tests for components and e2e tests for applications"),e.k0s(),e.j41(14,"li"),e.EFF(15,"provides default tooling (such as a test runner that builds an isolated module/application loader)"),e.k0s(),e.j41(16,"li"),e.EFF(17,"provides integration with "),e.j41(18,"a",9),e.EFF(19,"Jest"),e.k0s(),e.EFF(20," and "),e.j41(21,"a",10),e.EFF(22,"Supertest"),e.k0s(),e.EFF(23," out-of-the-box, while remaining agnostic to testing tools"),e.k0s(),e.j41(24,"li"),e.EFF(25,"makes the Nest dependency injection system available in the testing environment for easily mocking components"),e.k0s()(),e.j41(26,"p"),e.EFF(27,"As mentioned, you can use any "),e.j41(28,"strong"),e.EFF(29,"testing framework"),e.k0s(),e.EFF(30," that you like, as Nest doesn't force any specific tooling. Simply replace the elements needed (such as the test runner), and you will still enjoy the benefits of Nest's ready-made testing facilities."),e.k0s(),e.j41(31,"h4",11)(32,"span"),e.EFF(33,"Installation"),e.k0s()(),e.j41(34,"p"),e.EFF(35,"To get started, first install the required package:"),e.k0s(),e.j41(36,"pre")(37,"code",12),e.EFF(38,"\n$ npm i --save-dev @nestjs/testing\n"),e.k0s()(),e.j41(39,"h4",13)(40,"span"),e.EFF(41,"Unit testing"),e.k0s()(),e.j41(42,"p"),e.EFF(43,"In the following example, we test two classes: "),e.j41(44,"code"),e.EFF(45,"CatsController"),e.k0s(),e.EFF(46," and "),e.j41(47,"code"),e.EFF(48,"CatsService"),e.k0s(),e.EFF(49,". As mentioned, "),e.j41(50,"a",9),e.EFF(51,"Jest"),e.k0s(),e.EFF(52," is provided as the default testing framework. It serves as a test-runner and also provides assert functions and test-double utilities that help with mocking, spying, etc. In the following basic test, we manually instantiate these classes, and ensure that the controller and service fulfill their API contract."),e.k0s(),e.j41(53,"span",14),e.EFF(54),e.nI1(55,"extension"),e.nrm(56,"app-tabs",null,1),e.k0s(),e.j41(58,"pre")(59,"code",15),e.EFF(60,"\nimport { CatsController } from './cats.controller';\nimport { CatsService } from './cats.service';\n\ndescribe('CatsController', () => {\n  let catsController: CatsController;\n  let catsService: CatsService;\n\n  beforeEach(() => {\n    catsService = new CatsService();\n    catsController = new CatsController(catsService);\n  });\n\n  describe('findAll', () => {\n    it('should return an array of cats', async () => {\n      const result = ['test'];\n      jest.spyOn(catsService, 'findAll').mockImplementation(() => result);\n\n      expect(await catsController.findAll()).toBe(result);\n    });\n  });\n});\n"),e.k0s()(),e.j41(61,"pre")(62,"code",15),e.EFF(63,"\nimport { CatsController } from './cats.controller';\nimport { CatsService } from './cats.service';\n\ndescribe('CatsController', () => {\n  let catsController;\n  let catsService;\n\n  beforeEach(() => {\n    catsService = new CatsService();\n    catsController = new CatsController(catsService);\n  });\n\n  describe('findAll', () => {\n    it('should return an array of cats', async () => {\n      const result = ['test'];\n      jest.spyOn(catsService, 'findAll').mockImplementation(() => result);\n\n      expect(await catsController.findAll()).toBe(result);\n    });\n  });\n});\n"),e.k0s()(),e.j41(64,"blockquote",16)(65,"strong"),e.EFF(66,"Hint"),e.k0s(),e.EFF(67," Keep your test files located near the classes they test. Testing files should have a "),e.j41(68,"code"),e.EFF(69,".spec"),e.k0s(),e.EFF(70," or "),e.j41(71,"code"),e.EFF(72,".test"),e.k0s(),e.EFF(73," suffix.\n"),e.k0s(),e.j41(74,"p"),e.EFF(75,"Because the above sample is trivial, we aren't really testing anything Nest-specific. Indeed, we aren't even using dependency injection (notice that we pass an instance of "),e.j41(76,"code"),e.EFF(77,"CatsService"),e.k0s(),e.EFF(78," to our "),e.j41(79,"code"),e.EFF(80,"catsController"),e.k0s(),e.EFF(81,"). This form of testing - where we manually instantiate the classes being tested - is often called "),e.j41(82,"strong"),e.EFF(83,"isolated testing"),e.k0s(),e.EFF(84," as it is independent from the framework. Let's introduce some more advanced capabilities that help you test applications that make more extensive use of Nest features."),e.k0s(),e.j41(85,"h4",17)(86,"span"),e.EFF(87,"Testing utilities"),e.k0s()(),e.j41(88,"p"),e.EFF(89,"The "),e.j41(90,"code"),e.EFF(91,"@nestjs/testing"),e.k0s(),e.EFF(92," package provides a set of utilities that enable a more robust testing process. Let's rewrite the previous example using the built-in "),e.j41(93,"code"),e.EFF(94,"Test"),e.k0s(),e.EFF(95," class:"),e.k0s(),e.j41(96,"span",14),e.EFF(97),e.nI1(98,"extension"),e.nrm(99,"app-tabs",null,2),e.k0s(),e.j41(101,"pre")(102,"code",15),e.EFF(103,"\nimport { Test } from '@nestjs/testing';\nimport { CatsController } from './cats.controller';\nimport { CatsService } from './cats.service';\n\ndescribe('CatsController', () => {\n  let catsController: CatsController;\n  let catsService: CatsService;\n\n  beforeEach(async () => {\n    const moduleRef = await Test.createTestingModule({\n        controllers: [CatsController],\n        providers: [CatsService],\n      }).compile();\n\n    catsService = moduleRef.get(CatsService);\n    catsController = moduleRef.get(CatsController);\n  });\n\n  describe('findAll', () => {\n    it('should return an array of cats', async () => {\n      const result = ['test'];\n      jest.spyOn(catsService, 'findAll').mockImplementation(() => result);\n\n      expect(await catsController.findAll()).toBe(result);\n    });\n  });\n});\n"),e.k0s()(),e.j41(104,"pre")(105,"code",15),e.EFF(106,"\nimport { Test } from '@nestjs/testing';\nimport { CatsController } from './cats.controller';\nimport { CatsService } from './cats.service';\n\ndescribe('CatsController', () => {\n  let catsController;\n  let catsService;\n\n  beforeEach(async () => {\n    const moduleRef = await Test.createTestingModule({\n        controllers: [CatsController],\n        providers: [CatsService],\n      }).compile();\n\n    catsService = moduleRef.get(CatsService);\n    catsController = moduleRef.get(CatsController);\n  });\n\n  describe('findAll', () => {\n    it('should return an array of cats', async () => {\n      const result = ['test'];\n      jest.spyOn(catsService, 'findAll').mockImplementation(() => result);\n\n      expect(await catsController.findAll()).toBe(result);\n    });\n  });\n});\n"),e.k0s()(),e.j41(107,"p"),e.EFF(108,"The "),e.j41(109,"code"),e.EFF(110,"Test"),e.k0s(),e.EFF(111," class is useful for providing an application execution context that essentially mocks the full Nest runtime, but gives you hooks that make it easy to manage class instances, including mocking and overriding. The "),e.j41(112,"code"),e.EFF(113,"Test"),e.k0s(),e.EFF(114," class has a "),e.j41(115,"code"),e.EFF(116,"createTestingModule()"),e.k0s(),e.EFF(117," method that takes a module metadata object as its argument (the same object you pass to the "),e.j41(118,"code"),e.EFF(119,"@Module()"),e.k0s(),e.EFF(120," decorator). This method returns a "),e.j41(121,"code"),e.EFF(122,"TestingModule"),e.k0s(),e.EFF(123," instance which in turn provides a few methods. For unit tests, the important one is the "),e.j41(124,"code"),e.EFF(125,"compile()"),e.k0s(),e.EFF(126," method. This method bootstraps a module with its dependencies (similar to the way an application is bootstrapped in the conventional "),e.j41(127,"code"),e.EFF(128,"main.ts"),e.k0s(),e.EFF(129," file using "),e.j41(130,"code"),e.EFF(131,"NestFactory.create()"),e.k0s(),e.EFF(132,"), and returns a module that is ready for testing."),e.k0s(),e.j41(133,"blockquote",16)(134,"strong"),e.EFF(135,"Hint"),e.k0s(),e.EFF(136," The "),e.j41(137,"code"),e.EFF(138,"compile()"),e.k0s(),e.EFF(139," method is "),e.j41(140,"strong"),e.EFF(141,"asynchronous"),e.k0s(),e.EFF(142," and therefore has to be awaited. Once the module is compiled you can retrieve any "),e.j41(143,"strong"),e.EFF(144,"static"),e.k0s(),e.EFF(145," instance it declares (controllers and providers) using the "),e.j41(146,"code"),e.EFF(147,"get()"),e.k0s(),e.EFF(148," method.\n"),e.k0s(),e.j41(149,"p")(150,"code"),e.EFF(151,"TestingModule"),e.k0s(),e.EFF(152," inherits from the "),e.j41(153,"a",18),e.EFF(154,"module reference"),e.k0s(),e.EFF(155," class, and therefore its ability to dynamically resolve scoped providers (transient or request-scoped). Do this with the "),e.j41(156,"code"),e.EFF(157,"resolve()"),e.k0s(),e.EFF(158," method (the "),e.j41(159,"code"),e.EFF(160,"get()"),e.k0s(),e.EFF(161," method can only retrieve static instances)."),e.k0s(),e.j41(162,"pre")(163,"code",15),e.EFF(164,"\nconst moduleRef = await Test.createTestingModule({\n  controllers: [CatsController],\n  providers: [CatsService],\n}).compile();\n\ncatsService = await moduleRef.resolve(CatsService);\n"),e.k0s()(),e.j41(165,"blockquote",19)(166,"strong"),e.EFF(167,"Warning"),e.k0s(),e.EFF(168," The "),e.j41(169,"code"),e.EFF(170,"resolve()"),e.k0s(),e.EFF(171," method returns a unique instance of the provider, from its own "),e.j41(172,"strong"),e.EFF(173,"DI container sub-tree"),e.k0s(),e.EFF(174,". Each sub-tree has a unique context identifier. Thus, if you call this method more than once and compare instance references, you will see that they are not equal.\n"),e.k0s(),e.j41(175,"blockquote",16)(176,"strong"),e.EFF(177,"Hint"),e.k0s(),e.EFF(178," Learn more about the module reference features "),e.j41(179,"a",18),e.EFF(180,"here"),e.k0s(),e.EFF(181,".\n"),e.k0s(),e.j41(182,"p"),e.EFF(183,"Instead of using the production version of any provider, you can override it with a "),e.j41(184,"a",20),e.EFF(185,"custom provider"),e.k0s(),e.EFF(186," for testing purposes. For example, you can mock a database service instead of connecting to a live database. We'll cover overrides in the next section, but they're available for unit tests as well."),e.k0s(),e.j41(187,"p"),e.nrm(188,"app-banner-courses"),e.k0s(),e.j41(189,"h4",21)(190,"span"),e.EFF(191,"Auto mocking"),e.k0s()(),e.j41(192,"p"),e.EFF(193,"Nest also allows you to define a mock factory to apply to all of your missing dependencies. This is useful for cases where you have a large number of dependencies in a class and mocking all of them will take a long time and a lot of setup. To make use of this feature, the "),e.j41(194,"code"),e.EFF(195,"createTestingModule()"),e.k0s(),e.EFF(196," will need to be chained up with the "),e.j41(197,"code"),e.EFF(198,"useMocker()"),e.k0s(),e.EFF(199," method, passing a factory for your dependency mocks. This factory can take in an optional token, which is an instance token, any token which is valid for a Nest provider, and returns a mock implementation. The below is an example of creating a generic mocker using "),e.j41(200,"a",22)(201,"code"),e.EFF(202,"jest-mock"),e.k0s()(),e.EFF(203," and a specific mock for "),e.j41(204,"code"),e.EFF(205,"CatsService"),e.k0s(),e.EFF(206," using "),e.j41(207,"code"),e.EFF(208,"jest.fn()"),e.k0s(),e.EFF(209,"."),e.k0s(),e.j41(210,"pre")(211,"code",15),e.EFF(212,"\n// ...\nimport { ModuleMocker, MockFunctionMetadata } from 'jest-mock';\n\nconst moduleMocker = new ModuleMocker(global);\n\ndescribe('CatsController', () => {\n  let controller: CatsController;\n\n  beforeEach(async () => {\n    const moduleRef = await Test.createTestingModule({\n      controllers: [CatsController],\n    })\n      .useMocker((token) => {\n        const results = ['test1', 'test2'];\n        if (token === CatsService) {\n          return { findAll: jest.fn().mockResolvedValue(results) };\n        }\n        if (typeof token === 'function') {\n          const mockMetadata = moduleMocker.getMetadata(token) as MockFunctionMetadata<any, any>;\n          const Mock = moduleMocker.generateFromMetadata(mockMetadata);\n          return new Mock();\n        }\n      })\n      .compile();\n\n    controller = moduleRef.get(CatsController);\n  });\n});\n"),e.k0s()(),e.j41(213,"p"),e.EFF(214,"You can also retrieve these mocks out of the testing container as you normally would custom providers, "),e.j41(215,"code"),e.EFF(216,"moduleRef.get(CatsService)"),e.k0s(),e.EFF(217,"."),e.k0s(),e.j41(218,"blockquote",16)(219,"strong"),e.EFF(220,"Hint"),e.k0s(),e.EFF(221," A general mock factory, like "),e.j41(222,"code"),e.EFF(223,"createMock"),e.k0s(),e.EFF(224," from "),e.j41(225,"a",23)(226,"code"),e.EFF(227,"@golevelup/ts-jest"),e.k0s()(),e.EFF(228," can also be passed directly.\n"),e.k0s(),e.j41(229,"blockquote",16)(230,"strong"),e.EFF(231,"Hint"),e.k0s(),e.j41(232,"code"),e.EFF(233,"REQUEST"),e.k0s(),e.EFF(234," and "),e.j41(235,"code"),e.EFF(236,"INQUIRER"),e.k0s(),e.EFF(237," providers cannot be auto-mocked because they're already pre-defined in the context. However, they can be "),e.j41(238,"em"),e.EFF(239,"overwritten"),e.k0s(),e.EFF(240," using the custom provider syntax or by utilizing the "),e.j41(241,"code"),e.EFF(242,".overrideProvider"),e.k0s(),e.EFF(243," method.\n"),e.k0s(),e.j41(244,"h4",24)(245,"span"),e.EFF(246,"End-to-end testing"),e.k0s()(),e.j41(247,"p"),e.EFF(248,"Unlike unit testing, which focuses on individual modules and classes, end-to-end (e2e) testing covers the interaction of classes and modules at a more aggregate level -- closer to the kind of interaction that end-users will have with the production system. As an application grows, it becomes hard to manually test the end-to-end behavior of each API endpoint. Automated end-to-end tests help us ensure that the overall behavior of the system is correct and meets project requirements. To perform e2e tests we use a similar configuration to the one we just covered in "),e.j41(249,"strong"),e.EFF(250,"unit testing"),e.k0s(),e.EFF(251,". In addition, Nest makes it easy to use the "),e.j41(252,"a",10),e.EFF(253,"Supertest"),e.k0s(),e.EFF(254," library to simulate HTTP requests."),e.k0s(),e.j41(255,"span",14),e.EFF(256),e.nI1(257,"extension"),e.nrm(258,"app-tabs",null,3),e.k0s(),e.j41(260,"pre")(261,"code",15),e.EFF(262,"\nimport * as request from 'supertest';\nimport { Test } from '@nestjs/testing';\nimport { CatsModule } from '../../src/cats/cats.module';\nimport { CatsService } from '../../src/cats/cats.service';\nimport { INestApplication } from '@nestjs/common';\n\ndescribe('Cats', () => {\n  let app: INestApplication;\n  let catsService = { findAll: () => ['test'] };\n\n  beforeAll(async () => {\n    const moduleRef = await Test.createTestingModule({\n      imports: [CatsModule],\n    })\n      .overrideProvider(CatsService)\n      .useValue(catsService)\n      .compile();\n\n    app = moduleRef.createNestApplication();\n    await app.init();\n  });\n\n  it(`/GET cats`, () => {\n    return request(app.getHttpServer())\n      .get('/cats')\n      .expect(200)\n      .expect({\n        data: catsService.findAll(),\n      });\n  });\n\n  afterAll(async () => {\n    await app.close();\n  });\n});\n"),e.k0s()(),e.j41(263,"pre")(264,"code",15),e.EFF(265,"\nimport * as request from 'supertest';\nimport { Test } from '@nestjs/testing';\nimport { CatsModule } from '../../src/cats/cats.module';\nimport { CatsService } from '../../src/cats/cats.service';\nimport { INestApplication } from '@nestjs/common';\n\ndescribe('Cats', () => {\n  let app: INestApplication;\n  let catsService = { findAll: () => ['test'] };\n\n  beforeAll(async () => {\n    const moduleRef = await Test.createTestingModule({\n      imports: [CatsModule],\n    })\n      .overrideProvider(CatsService)\n      .useValue(catsService)\n      .compile();\n\n    app = moduleRef.createNestApplication();\n    await app.init();\n  });\n\n  it(`/GET cats`, () => {\n    return request(app.getHttpServer())\n      .get('/cats')\n      .expect(200)\n      .expect({\n        data: catsService.findAll(),\n      });\n  });\n\n  afterAll(async () => {\n    await app.close();\n  });\n});\n"),e.k0s()(),e.j41(266,"blockquote",16)(267,"strong"),e.EFF(268,"Hint"),e.k0s(),e.EFF(269," If you're using "),e.j41(270,"a",25),e.EFF(271,"Fastify"),e.k0s(),e.EFF(272," as your HTTP adapter, it requires a slightly different configuration, and has built-in testing capabilities:\n"),e.j41(273,"pre")(274,"code",26),e.EFF(275,"\nlet app: NestFastifyApplication;\n\nbeforeAll(async () => {\n  app = moduleRef.createNestApplication<NestFastifyApplication>(new FastifyAdapter());\n\n  await app.init();\n  await app.getHttpAdapter().getInstance().ready();\n});\n\nit(`/GET cats`, () => {\n  return app\n    .inject({\n      method: 'GET',\n      url: '/cats',\n    })\n    .then((result) => {\n      expect(result.statusCode).toEqual(200);\n      expect(result.payload).toEqual(/* expectedPayload */);\n    });\n});\n\nafterAll(async () => {\n  await app.close();\n});\n"),e.k0s()()(),e.j41(276,"p"),e.EFF(277,"In this example, we build on some of the concepts described earlier. In addition to the "),e.j41(278,"code"),e.EFF(279,"compile()"),e.k0s(),e.EFF(280," method we used earlier, we now use the "),e.j41(281,"code"),e.EFF(282,"createNestApplication()"),e.k0s(),e.EFF(283," method to instantiate a full Nest runtime environment. We save a reference to the running app in our "),e.j41(284,"code"),e.EFF(285,"app"),e.k0s(),e.EFF(286," variable so we can use it to simulate HTTP requests."),e.k0s(),e.j41(287,"p"),e.EFF(288,"We simulate HTTP tests using the "),e.j41(289,"code"),e.EFF(290,"request()"),e.k0s(),e.EFF(291," function from Supertest. We want these HTTP requests to route to our running Nest app, so we pass the "),e.j41(292,"code"),e.EFF(293,"request()"),e.k0s(),e.EFF(294," function a reference to the HTTP listener that underlies Nest (which, in turn, may be provided by the Express platform). Hence the construction "),e.j41(295,"code"),e.EFF(296,"request(app.getHttpServer())"),e.k0s(),e.EFF(297,". The call to "),e.j41(298,"code"),e.EFF(299,"request()"),e.k0s(),e.EFF(300," hands us a wrapped HTTP Server, now connected to the Nest app, which exposes methods to simulate an actual HTTP request. For example, using "),e.j41(301,"code"),e.EFF(302,"request(...).get('/cats')"),e.k0s(),e.EFF(303," will initiate a request to the Nest app that is identical to an "),e.j41(304,"strong"),e.EFF(305,"actual"),e.k0s(),e.EFF(306," HTTP request like "),e.j41(307,"code"),e.EFF(308,"get '/cats'"),e.k0s(),e.EFF(309," coming in over the network."),e.k0s(),e.j41(310,"p"),e.EFF(311,"In this example, we also provide an alternate (test-double) implementation of the "),e.j41(312,"code"),e.EFF(313,"CatsService"),e.k0s(),e.EFF(314," which simply returns a hard-coded value that we can test for. Use "),e.j41(315,"code"),e.EFF(316,"overrideProvider()"),e.k0s(),e.EFF(317," to provide such an alternate implementation. Similarly, Nest provides methods to override modules, guards, interceptors, filters and pipes with the "),e.j41(318,"code"),e.EFF(319,"overrideModule()"),e.k0s(),e.EFF(320,", "),e.j41(321,"code"),e.EFF(322,"overrideGuard()"),e.k0s(),e.EFF(323,", "),e.j41(324,"code"),e.EFF(325,"overrideInterceptor()"),e.k0s(),e.EFF(326,", "),e.j41(327,"code"),e.EFF(328,"overrideFilter()"),e.k0s(),e.EFF(329,", and "),e.j41(330,"code"),e.EFF(331,"overridePipe()"),e.k0s(),e.EFF(332," methods respectively."),e.k0s(),e.j41(333,"p"),e.EFF(334,"Each of the override methods (except for "),e.j41(335,"code"),e.EFF(336,"overrideModule()"),e.k0s(),e.EFF(337,") returns an object with 3 different methods that mirror those described for "),e.j41(338,"a",27),e.EFF(339,"custom providers"),e.k0s(),e.EFF(340,":"),e.k0s(),e.j41(341,"ul")(342,"li")(343,"code"),e.EFF(344,"useClass"),e.k0s(),e.EFF(345,": you supply a class that will be instantiated to provide the instance to override the object (provider, guard, etc.)."),e.k0s(),e.j41(346,"li")(347,"code"),e.EFF(348,"useValue"),e.k0s(),e.EFF(349,": you supply an instance that will override the object."),e.k0s(),e.j41(350,"li")(351,"code"),e.EFF(352,"useFactory"),e.k0s(),e.EFF(353,": you supply a function that returns an instance that will override the object."),e.k0s()(),e.j41(354,"p"),e.EFF(355,"On the other hand, "),e.j41(356,"code"),e.EFF(357,"overrideModule()"),e.k0s(),e.EFF(358," returns an object with the "),e.j41(359,"code"),e.EFF(360,"useModule()"),e.k0s(),e.EFF(361," method, which you can use to supply a module that will override the original module, as follows:"),e.k0s(),e.j41(362,"pre")(363,"code",15),e.EFF(364,"\nconst moduleRef = await Test.createTestingModule({\n  imports: [AppModule],\n})\n  .overrideModule(CatsModule)\n  .useModule(AlternateCatsModule)\n  .compile();\n"),e.k0s()(),e.j41(365,"p"),e.EFF(366,"Each of the override method types, in turn, returns the "),e.j41(367,"code"),e.EFF(368,"TestingModule"),e.k0s(),e.EFF(369," instance, and can thus be chained with other methods in the "),e.j41(370,"a",28),e.EFF(371,"fluent style"),e.k0s(),e.EFF(372,". You should use "),e.j41(373,"code"),e.EFF(374,"compile()"),e.k0s(),e.EFF(375," at the end of such a chain to cause Nest to instantiate and initialize the module."),e.k0s(),e.j41(376,"p"),e.EFF(377,"Also, sometimes you may want to provide a custom logger e.g. when the tests are run (for example, on a CI server). Use the "),e.j41(378,"code"),e.EFF(379,"setLogger()"),e.k0s(),e.EFF(380," method and pass an object that fulfills the "),e.j41(381,"code"),e.EFF(382,"LoggerService"),e.k0s(),e.EFF(383," interface to instruct the "),e.j41(384,"code"),e.EFF(385,"TestModuleBuilder"),e.k0s(),e.EFF(386,' how to log during tests (by default, only "error" logs will be logged to the console).'),e.k0s(),e.j41(387,"p"),e.EFF(388,"The compiled module has several useful methods, as described in the following table:"),e.k0s(),e.j41(389,"table")(390,"tr")(391,"td")(392,"code"),e.EFF(393,"createNestApplication()"),e.k0s()(),e.j41(394,"td"),e.EFF(395," Creates and returns a Nest application ("),e.j41(396,"code"),e.EFF(397,"INestApplication"),e.k0s(),e.EFF(398," instance) based on the given module. Note that you must manually initialize the application using the "),e.j41(399,"code"),e.EFF(400,"init()"),e.k0s(),e.EFF(401," method. "),e.k0s()(),e.j41(402,"tr")(403,"td")(404,"code"),e.EFF(405,"createNestMicroservice()"),e.k0s()(),e.j41(406,"td"),e.EFF(407," Creates and returns a Nest microservice ("),e.j41(408,"code"),e.EFF(409,"INestMicroservice"),e.k0s(),e.EFF(410," instance) based on the given module. "),e.k0s()(),e.j41(411,"tr")(412,"td")(413,"code"),e.EFF(414,"get()"),e.k0s()(),e.j41(415,"td"),e.EFF(416," Retrieves a static instance of a controller or provider (including guards, filters, etc.) available in the application context. Inherited from the "),e.j41(417,"a",29),e.EFF(418,"module reference"),e.k0s(),e.EFF(419," class. "),e.k0s()(),e.j41(420,"tr")(421,"td")(422,"code"),e.EFF(423,"resolve()"),e.k0s()(),e.j41(424,"td"),e.EFF(425," Retrieves a dynamically created scoped instance (request or transient) of a controller or provider (including guards, filters, etc.) available in the application context. Inherited from the "),e.j41(426,"a",29),e.EFF(427,"module reference"),e.k0s(),e.EFF(428," class. "),e.k0s()(),e.j41(429,"tr")(430,"td")(431,"code"),e.EFF(432,"select()"),e.k0s()(),e.j41(433,"td"),e.EFF(434," Navigates through the module's dependency graph; can be used to retrieve a specific instance from the selected module (used along with strict mode ("),e.j41(435,"code"),e.EFF(436,"strict: true"),e.k0s(),e.EFF(437,") in "),e.j41(438,"code"),e.EFF(439,"get()"),e.k0s(),e.EFF(440," method). "),e.k0s()()(),e.j41(441,"blockquote",16)(442,"strong"),e.EFF(443,"Hint"),e.k0s(),e.EFF(444," Keep your e2e test files inside the "),e.j41(445,"code"),e.EFF(446,"test"),e.k0s(),e.EFF(447," directory. The testing files should have a "),e.j41(448,"code"),e.EFF(449,".e2e-spec"),e.k0s(),e.EFF(450," suffix.\n"),e.k0s(),e.j41(451,"h4",30)(452,"span"),e.EFF(453,"Overriding globally registered enhancers"),e.k0s()(),e.j41(454,"p"),e.EFF(455,"If you have a globally registered guard (or pipe, interceptor, or filter), you need to take a few more steps to override that enhancer. To recap the original registration looks like this:"),e.k0s(),e.j41(456,"pre")(457,"code",15),e.EFF(458,"\nproviders: [\n  {\n    provide: APP_GUARD,\n    useClass: JwtAuthGuard,\n  },\n],\n"),e.k0s()(),e.j41(459,"p"),e.EFF(460,'This is registering the guard as a "multi"-provider through the '),e.j41(461,"code"),e.EFF(462,"APP_*"),e.k0s(),e.EFF(463," token. To be able to replace the "),e.j41(464,"code"),e.EFF(465,"JwtAuthGuard"),e.k0s(),e.EFF(466," here, the registration needs to use an existing provider in this slot:"),e.k0s(),e.j41(467,"pre")(468,"code",15),e.EFF(469,"\nproviders: [\n  {\n    provide: APP_GUARD,\n    useExisting: JwtAuthGuard,\n    // ^^^^^^^^ notice the use of 'useExisting' instead of 'useClass'\n  },\n  JwtAuthGuard,\n],\n"),e.k0s()(),e.j41(470,"blockquote",16)(471,"strong"),e.EFF(472,"Hint"),e.k0s(),e.EFF(473," Change the "),e.j41(474,"code"),e.EFF(475,"useClass"),e.k0s(),e.EFF(476," to "),e.j41(477,"code"),e.EFF(478,"useExisting"),e.k0s(),e.EFF(479," to reference a registered provider instead of having Nest instantiate it behind the token.\n"),e.k0s(),e.j41(480,"p"),e.EFF(481,"Now the "),e.j41(482,"code"),e.EFF(483,"JwtAuthGuard"),e.k0s(),e.EFF(484," is visible to Nest as a regular provider that can be overridden when creating the "),e.j41(485,"code"),e.EFF(486,"TestingModule"),e.k0s(),e.EFF(487,":"),e.k0s(),e.j41(488,"pre")(489,"code",15),e.EFF(490,"\nconst moduleRef = await Test.createTestingModule({\n  imports: [AppModule],\n})\n  .overrideProvider(JwtAuthGuard)\n  .useClass(MockAuthGuard)\n  .compile();\n"),e.k0s()(),e.j41(491,"p"),e.EFF(492,"Now all your tests will use the "),e.j41(493,"code"),e.EFF(494,"MockAuthGuard"),e.k0s(),e.EFF(495," on every request."),e.k0s(),e.j41(496,"h4",31)(497,"span"),e.EFF(498,"Testing request-scoped instances"),e.k0s()(),e.j41(499,"p")(500,"a",32),e.EFF(501,"Request-scoped"),e.k0s(),e.EFF(502," providers are created uniquely for each incoming "),e.j41(503,"strong"),e.EFF(504,"request"),e.k0s(),e.EFF(505,". The instance is garbage-collected after the request has completed processing. This poses a problem, because we can't access a dependency injection sub-tree generated specifically for a tested request."),e.k0s(),e.j41(506,"p"),e.EFF(507,"We know (based on the sections above) that the "),e.j41(508,"code"),e.EFF(509,"resolve()"),e.k0s(),e.EFF(510," method can be used to retrieve a dynamically instantiated class. Also, as described "),e.j41(511,"a",33),e.EFF(512,"here"),e.k0s(),e.EFF(513,", we know we can pass a unique context identifier to control the lifecycle of a DI container sub-tree. How do we leverage this in a testing context?"),e.k0s(),e.j41(514,"p"),e.EFF(515,"The strategy is to generate a context identifier beforehand and force Nest to use this particular ID to create a sub-tree for all incoming requests. In this way we'll be able to retrieve instances created for a tested request."),e.k0s(),e.j41(516,"p"),e.EFF(517,"To accomplish this, use "),e.j41(518,"code"),e.EFF(519,"jest.spyOn()"),e.k0s(),e.EFF(520," on the "),e.j41(521,"code"),e.EFF(522,"ContextIdFactory"),e.k0s(),e.EFF(523,":"),e.k0s(),e.j41(524,"pre")(525,"code",15),e.EFF(526,"\nconst contextId = ContextIdFactory.create();\njest.spyOn(ContextIdFactory, 'getByRequest').mockImplementation(() => contextId);\n"),e.k0s()(),e.j41(527,"p"),e.EFF(528,"Now we can use the "),e.j41(529,"code"),e.EFF(530,"contextId"),e.k0s(),e.EFF(531," to access a single generated DI container sub-tree for any subsequent request."),e.k0s(),e.j41(532,"pre")(533,"code",15),e.EFF(534,"\ncatsService = await moduleRef.resolve(CatsService, contextId);\n"),e.k0s()()()),2&s){const a=e.sdS(57),r=e.sdS(100),i=e.sdS(259);e.R7$(54),e.SpI(" ",e.i5U(55,15,"cats.controller.spec",a.isJsActive),"\n"),e.R7$(4),e.AVh("hide",a.isJsActive),e.R7$(3),e.AVh("hide",!a.isJsActive),e.R7$(36),e.SpI(" ",e.i5U(98,18,"cats.controller.spec",r.isJsActive),"\n"),e.R7$(4),e.AVh("hide",r.isJsActive),e.R7$(3),e.AVh("hide",!r.isJsActive),e.R7$(152),e.SpI(" ",e.i5U(257,21,"cats.e2e-spec",i.isJsActive),"\n"),e.R7$(4),e.AVh("hide",i.isJsActive),e.R7$(3),e.AVh("hide",!i.isJsActive)}},dependencies:[E.O,l.a,k.Q,p.Wk,f.M],encapsulation:2,changeDetection:0})}return t})(),data:{title:"Testing"}},{path:"injection-scopes",component:(()=>{class t extends F.y{static \u0275fac=(()=>{let o;return function(n){return(o||(o=e.xGo(t)))(n||t)}})();static \u0275cmp=e.VBU({type:t,selectors:[["app-provider-scopes"]],features:[e.Vt3],decls:390,vars:0,consts:[["contentReference",""],[1,"content"],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/provider-scopes.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","injection-scopes"],["appAnchor","","id","provider-scope"],[1,"info"],["appAnchor","","id","usage"],[1,"language-typescript"],["routerLink","/fundamentals/custom-providers"],[1,"warning"],["href","../security/authentication#request-scoped-strategies"],["appAnchor","","id","controller-scope"],["appAnchor","","id","scope-hierarchy"],["appAnchor","","id","request-provider"],["routerLink","/graphql/quick-start"],["appAnchor","","id","inquirer-provider"],["appAnchor","","id","performance"],["appAnchor","","id","durable-providers"],["href","/fundamentals/module-ref#resolving-scoped-providers"]],template:function(s,n){1&s&&(e.j41(0,"div",1,0)(2,"div",2)(3,"a",3),e.nrm(4,"i",4),e.k0s()(),e.j41(5,"h3",5),e.EFF(6,"Injection scopes"),e.k0s(),e.j41(7,"p"),e.EFF(8,"For people coming from different programming language backgrounds, it might be unexpected to learn that in Nest, almost everything is shared across incoming requests. We have a connection pool to the database, singleton services with global state, etc. Remember that Node.js doesn't follow the request/response Multi-Threaded Stateless Model in which every request is processed by a separate thread. Hence, using singleton instances is fully "),e.j41(9,"strong"),e.EFF(10,"safe"),e.k0s(),e.EFF(11," for our applications."),e.k0s(),e.j41(12,"p"),e.EFF(13,"However, there are edge cases when request-based lifetime may be the desired behavior, for instance, per-request caching in GraphQL applications, request tracking, and multi-tenancy. Injection scopes provide a mechanism to obtain the desired provider lifetime behavior."),e.k0s(),e.j41(14,"h4",6)(15,"span"),e.EFF(16,"Provider scope"),e.k0s()(),e.j41(17,"p"),e.EFF(18,"A provider can have any of the following scopes:"),e.k0s(),e.j41(19,"table")(20,"tr")(21,"td")(22,"code"),e.EFF(23,"DEFAULT"),e.k0s()(),e.j41(24,"td"),e.EFF(25,"A single instance of the provider is shared across the entire application. The instance lifetime is tied directly to the application lifecycle. Once the application has bootstrapped, all singleton providers have been instantiated. Singleton scope is used by default."),e.k0s()(),e.j41(26,"tr")(27,"td")(28,"code"),e.EFF(29,"REQUEST"),e.k0s()(),e.j41(30,"td"),e.EFF(31,"A new instance of the provider is created exclusively for each incoming "),e.j41(32,"strong"),e.EFF(33,"request"),e.k0s(),e.EFF(34,". The instance is garbage-collected after the request has completed processing."),e.k0s()(),e.j41(35,"tr")(36,"td")(37,"code"),e.EFF(38,"TRANSIENT"),e.k0s()(),e.j41(39,"td"),e.EFF(40,"Transient providers are not shared across consumers. Each consumer that injects a transient provider will receive a new, dedicated instance."),e.k0s()()(),e.j41(41,"blockquote",7)(42,"strong"),e.EFF(43,"Hint"),e.k0s(),e.EFF(44," Using singleton scope is "),e.j41(45,"strong"),e.EFF(46,"recommended"),e.k0s(),e.EFF(47," for most use cases. Sharing providers across consumers and across requests means that an instance can be cached and its initialization occurs only once, during application startup.\n"),e.k0s(),e.j41(48,"h4",8)(49,"span"),e.EFF(50,"Usage"),e.k0s()(),e.j41(51,"p"),e.EFF(52,"Specify injection scope by passing the "),e.j41(53,"code"),e.EFF(54,"scope"),e.k0s(),e.EFF(55," property to the "),e.j41(56,"code"),e.EFF(57,"@Injectable()"),e.k0s(),e.EFF(58," decorator options object:"),e.k0s(),e.j41(59,"pre")(60,"code",9),e.EFF(61,"\nimport { Injectable, Scope } from '@nestjs/common';\n\n@Injectable({ scope: Scope.REQUEST })\nexport class CatsService {}\n"),e.k0s()(),e.j41(62,"p"),e.EFF(63,"Similarly, for "),e.j41(64,"a",10),e.EFF(65,"custom providers"),e.k0s(),e.EFF(66,", set the "),e.j41(67,"code"),e.EFF(68,"scope"),e.k0s(),e.EFF(69," property in the long-hand form for a provider registration:"),e.k0s(),e.j41(70,"pre")(71,"code",9),e.EFF(72,"\n{\n  provide: 'CACHE_MANAGER',\n  useClass: CacheManager,\n  scope: Scope.TRANSIENT,\n}\n"),e.k0s()(),e.j41(73,"blockquote",7)(74,"strong"),e.EFF(75,"Hint"),e.k0s(),e.EFF(76," Import the "),e.j41(77,"code"),e.EFF(78,"Scope"),e.k0s(),e.EFF(79," enum from "),e.j41(80,"code"),e.EFF(81,"@nestjs/common"),e.k0s()(),e.j41(82,"p"),e.EFF(83,"Singleton scope is used by default and does not need be declared. If you do want to declare a provider as singleton scoped, use the "),e.j41(84,"code"),e.EFF(85,"Scope.DEFAULT"),e.k0s(),e.EFF(86," value for the "),e.j41(87,"code"),e.EFF(88,"scope"),e.k0s(),e.EFF(89," property."),e.k0s(),e.j41(90,"blockquote",11)(91,"strong"),e.EFF(92,"Notice"),e.k0s(),e.EFF(93," Websocket Gateways should not use request-scoped providers because they must act as singletons. Each gateway encapsulates a real socket and cannot be instantiated multiple times. The limitation also applies to some other providers, like "),e.j41(94,"a",12)(95,"em"),e.EFF(96,"Passport strategies"),e.k0s()(),e.EFF(97," or "),e.j41(98,"em"),e.EFF(99,"Cron controllers"),e.k0s(),e.EFF(100,".\n"),e.k0s(),e.j41(101,"h4",13)(102,"span"),e.EFF(103,"Controller scope"),e.k0s()(),e.j41(104,"p"),e.EFF(105,"Controllers can also have scope, which applies to all request method handlers declared in that controller. Like provider scope, the scope of a controller declares its lifetime. For a request-scoped controller, a new instance is created for each inbound request, and garbage-collected when the request has completed processing."),e.k0s(),e.j41(106,"p"),e.EFF(107,"Declare controller scope with the "),e.j41(108,"code"),e.EFF(109,"scope"),e.k0s(),e.EFF(110," property of the "),e.j41(111,"code"),e.EFF(112,"ControllerOptions"),e.k0s(),e.EFF(113," object:"),e.k0s(),e.j41(114,"pre")(115,"code",9),e.EFF(116,"\n@Controller({\n  path: 'cats',\n  scope: Scope.REQUEST,\n})\nexport class CatsController {}\n"),e.k0s()(),e.j41(117,"h4",14)(118,"span"),e.EFF(119,"Scope hierarchy"),e.k0s()(),e.j41(120,"p"),e.EFF(121,"The "),e.j41(122,"code"),e.EFF(123,"REQUEST"),e.k0s(),e.EFF(124," scope bubbles up the injection chain. A controller that depends on a request-scoped provider will, itself, be request-scoped."),e.k0s(),e.j41(125,"p"),e.EFF(126,"Imagine the following dependency graph: "),e.j41(127,"code"),e.EFF(128,"CatsController <- CatsService <- CatsRepository"),e.k0s(),e.EFF(129,". If "),e.j41(130,"code"),e.EFF(131,"CatsService"),e.k0s(),e.EFF(132," is request-scoped (and the others are default singletons), the "),e.j41(133,"code"),e.EFF(134,"CatsController"),e.k0s(),e.EFF(135," will become request-scoped as it is dependent on the injected service. The "),e.j41(136,"code"),e.EFF(137,"CatsRepository"),e.k0s(),e.EFF(138,", which is not dependent, would remain singleton-scoped."),e.k0s(),e.j41(139,"p"),e.EFF(140,"Transient-scoped dependencies don't follow that pattern. If a singleton-scoped "),e.j41(141,"code"),e.EFF(142,"DogsService"),e.k0s(),e.EFF(143," injects a transient "),e.j41(144,"code"),e.EFF(145,"LoggerService"),e.k0s(),e.EFF(146," provider, it will receive a fresh instance of it. However, "),e.j41(147,"code"),e.EFF(148,"DogsService"),e.k0s(),e.EFF(149," will stay singleton-scoped, so injecting it anywhere would "),e.j41(150,"em"),e.EFF(151,"not"),e.k0s(),e.EFF(152," resolve to a new instance of "),e.j41(153,"code"),e.EFF(154,"DogsService"),e.k0s(),e.EFF(155,". In case it's desired behavior, "),e.j41(156,"code"),e.EFF(157,"DogsService"),e.k0s(),e.EFF(158," must be explicitly marked as "),e.j41(159,"code"),e.EFF(160,"TRANSIENT"),e.k0s(),e.EFF(161," as well."),e.k0s(),e.j41(162,"p"),e.nrm(163,"app-banner-courses"),e.k0s(),e.j41(164,"h4",15)(165,"span"),e.EFF(166,"Request provider"),e.k0s()(),e.j41(167,"p"),e.EFF(168,"In an HTTP server-based application (e.g., using "),e.j41(169,"code"),e.EFF(170,"@nestjs/platform-express"),e.k0s(),e.EFF(171," or "),e.j41(172,"code"),e.EFF(173,"@nestjs/platform-fastify"),e.k0s(),e.EFF(174,"), you may want to access a reference to the original request object when using request-scoped providers. You can do this by injecting the "),e.j41(175,"code"),e.EFF(176,"REQUEST"),e.k0s(),e.EFF(177," object."),e.k0s(),e.j41(178,"p"),e.EFF(179,"The "),e.j41(180,"code"),e.EFF(181,"REQUEST"),e.k0s(),e.EFF(182," provider is request-scoped, so you don't need to explicitly use the "),e.j41(183,"code"),e.EFF(184,"REQUEST"),e.k0s(),e.EFF(185," scope in this case."),e.k0s(),e.j41(186,"pre")(187,"code",9),e.EFF(188,"\nimport { Injectable, Scope, Inject } from '@nestjs/common';\nimport { REQUEST } from '@nestjs/core';\nimport { Request } from 'express';\n\n@Injectable({ scope: Scope.REQUEST })\nexport class CatsService {\n  constructor(@Inject(REQUEST) private request: Request) {}\n}\n"),e.k0s()(),e.j41(189,"p"),e.EFF(190,"Because of underlying platform/protocol differences, you access the inbound request slightly differently for Microservice or GraphQL applications. In "),e.j41(191,"a",16),e.EFF(192,"GraphQL"),e.k0s(),e.EFF(193," applications, you inject "),e.j41(194,"code"),e.EFF(195,"CONTEXT"),e.k0s(),e.EFF(196," instead of "),e.j41(197,"code"),e.EFF(198,"REQUEST"),e.k0s(),e.EFF(199,":"),e.k0s(),e.j41(200,"pre")(201,"code",9),e.EFF(202,"\nimport { Injectable, Scope, Inject } from '@nestjs/common';\nimport { CONTEXT } from '@nestjs/graphql';\n\n@Injectable({ scope: Scope.REQUEST })\nexport class CatsService {\n  constructor(@Inject(CONTEXT) private context) {}\n}\n"),e.k0s()(),e.j41(203,"p"),e.EFF(204,"You then configure your "),e.j41(205,"code"),e.EFF(206,"context"),e.k0s(),e.EFF(207," value (in the "),e.j41(208,"code"),e.EFF(209,"GraphQLModule"),e.k0s(),e.EFF(210,") to contain "),e.j41(211,"code"),e.EFF(212,"request"),e.k0s(),e.EFF(213," as its property."),e.k0s(),e.j41(214,"h4",17)(215,"span"),e.EFF(216,"Inquirer provider"),e.k0s()(),e.j41(217,"p"),e.EFF(218,"If you want to get the class where a provider was constructed, for instance in logging or metrics providers, you can inject the "),e.j41(219,"code"),e.EFF(220,"INQUIRER"),e.k0s(),e.EFF(221," token."),e.k0s(),e.j41(222,"pre")(223,"code",9),e.EFF(224,"\nimport { Inject, Injectable, Scope } from '@nestjs/common';\nimport { INQUIRER } from '@nestjs/core';\n\n@Injectable({ scope: Scope.TRANSIENT })\nexport class HelloService {\n  constructor(@Inject(INQUIRER) private parentClass: object) {}\n\n  sayHello(message: string) {\n    console.log(`${this.parentClass?.constructor?.name}: ${message}`);\n  }\n}\n"),e.k0s()(),e.j41(225,"p"),e.EFF(226,"And then use it as follows:"),e.k0s(),e.j41(227,"pre")(228,"code",9),e.EFF(229,"\nimport { Injectable } from '@nestjs/common';\nimport { HelloService } from './hello.service';\n\n@Injectable()\nexport class AppService {\n  constructor(private helloService: HelloService) {}\n\n  getRoot(): string {\n    this.helloService.sayHello('My name is getRoot');\n\n    return 'Hello world!';\n  }\n}\n"),e.k0s()(),e.j41(230,"p"),e.EFF(231,"In the example above when "),e.j41(232,"code"),e.EFF(233,"AppService#getRoot"),e.k0s(),e.EFF(234," is called, "),e.j41(235,"code"),e.EFF(236,'"AppService: My name is getRoot"'),e.k0s(),e.EFF(237," will be logged to the console."),e.k0s(),e.j41(238,"h4",18)(239,"span"),e.EFF(240,"Performance"),e.k0s()(),e.j41(241,"p"),e.EFF(242,"Using request-scoped providers will have an impact on application performance. While Nest tries to cache as much metadata as possible, it will still have to create an instance of your class on each request. Hence, it will slow down your average response time and overall benchmarking result. Unless a provider must be request-scoped, it is strongly recommended that you use the default singleton scope."),e.k0s(),e.j41(243,"blockquote",7)(244,"strong"),e.EFF(245,"Hint"),e.k0s(),e.EFF(246," Although it all sounds quite intimidating, a properly designed application that leverages request-scoped providers should not slow down by more than ~5% latency-wise.\n"),e.k0s(),e.j41(247,"h4",19)(248,"span"),e.EFF(249,"Durable providers"),e.k0s()(),e.j41(250,"p"),e.EFF(251,"Request-scoped providers, as mentioned in the section above, may lead to increased latency since having at least 1 request-scoped provider (injected into the controller instance, or deeper - injected into one of its providers) makes the controller request-scoped as well. That means it must be recreated (instantiated) per each individual request (and garbage collected afterward). Now, that also means, that for let's say 30k requests in parallel, there will be 30k ephemeral instances of the controller (and its request-scoped providers)."),e.k0s(),e.j41(252,"p"),e.EFF(253,"Having a common provider that most providers depend on (think of a database connection, or a logger service), automatically converts all those providers to request-scoped providers as well. This can pose a challenge in "),e.j41(254,"strong"),e.EFF(255,"multi-tenant applications"),e.k0s(),e.EFF(256,', especially for those that have a central request-scoped "data source" provider that grabs headers/token from the request object and based on its values, retrieves the corresponding database connection/schema (specific to that tenant).'),e.k0s(),e.j41(257,"p"),e.EFF(258,"For instance, let's say you have an application alternately used by 10 different customers. Each customer has its "),e.j41(259,"strong"),e.EFF(260,"own dedicated data source"),e.k0s(),e.EFF(261,', and you want to make sure customer A will never be able to reach customer B\'s database. One way to achieve this could be to declare a request-scoped "data source" provider that - based on the request object - determines what\'s the "current customer" and retrieves its corresponding database. With this approach, you can turn your application into a multi-tenant application in just a few minutes. But, a major downside to this approach is that since most likely a large chunk of your application\' components rely on the "data source" provider, they will implicitly become "request-scoped", and therefore you will undoubtedly see an impact in your apps performance.'),e.k0s(),e.j41(262,"p"),e.EFF(263,"But what if we had a better solution? Since we only have 10 customers, couldn't we have 10 individual "),e.j41(264,"a",20),e.EFF(265,"DI sub-trees"),e.k0s(),e.EFF(266," per customer (instead of recreating each tree per request)? If your providers don't rely on any property that's truly unique for each consecutive request (e.g., request UUID) but instead there're some specific attributes that let us aggregate (classify) them, there's no reason to "),e.j41(267,"em"),e.EFF(268,"recreate DI sub-tree"),e.k0s(),e.EFF(269," on every incoming request."),e.k0s(),e.j41(270,"p"),e.EFF(271,"And that's exactly when the "),e.j41(272,"strong"),e.EFF(273,"durable providers"),e.k0s(),e.EFF(274," come in handy."),e.k0s(),e.j41(275,"p"),e.EFF(276,"Before we start flagging providers as durable, we must first register a "),e.j41(277,"strong"),e.EFF(278,"strategy"),e.k0s(),e.EFF(279,' that instructs Nest what are those "common request attributes", provide logic that groups requests - associates them with their corresponding DI sub-trees.'),e.k0s(),e.j41(280,"pre")(281,"code",9),e.EFF(282,"\nimport {\n  HostComponentInfo,\n  ContextId,\n  ContextIdFactory,\n  ContextIdStrategy,\n} from '@nestjs/core';\nimport { Request } from 'express';\n\nconst tenants = new Map<string, ContextId>();\n\nexport class AggregateByTenantContextIdStrategy implements ContextIdStrategy {\n  attach(contextId: ContextId, request: Request) {\n    const tenantId = request.headers['x-tenant-id'] as string;\n    let tenantSubTreeId: ContextId;\n\n    if (tenants.has(tenantId)) {\n      tenantSubTreeId = tenants.get(tenantId);\n    } else {\n      tenantSubTreeId = ContextIdFactory.create();\n      tenants.set(tenantId, tenantSubTreeId);\n    }\n\n    // If tree is not durable, return the original \"contextId\" object\n    return (info: HostComponentInfo) =>\n      info.isTreeDurable ? tenantSubTreeId : contextId;\n  }\n}\n"),e.k0s()(),e.j41(283,"blockquote",7)(284,"strong"),e.EFF(285,"Hint"),e.k0s(),e.EFF(286," Similar to the request scope, durability bubbles up the injection chain. That means if A depends on B which is flagged as "),e.j41(287,"code"),e.EFF(288,"durable"),e.k0s(),e.EFF(289,", A implicitly becomes durable too (unless "),e.j41(290,"code"),e.EFF(291,"durable"),e.k0s(),e.EFF(292," is explicitly set to "),e.j41(293,"code"),e.EFF(294,"false"),e.k0s(),e.EFF(295," for A provider).\n"),e.k0s(),e.j41(296,"blockquote",11)(297,"strong"),e.EFF(298,"Warning"),e.k0s(),e.EFF(299," Note this strategy is not ideal for applications operating with a large number of tenants.\n"),e.k0s(),e.j41(300,"p"),e.EFF(301,"The value returned from the "),e.j41(302,"code"),e.EFF(303,"attach"),e.k0s(),e.EFF(304," method instructs Nest what context identifier should be used for a given host. In this case, we specified that the "),e.j41(305,"code"),e.EFF(306,"tenantSubTreeId"),e.k0s(),e.EFF(307," should be used instead of the original, auto-generated "),e.j41(308,"code"),e.EFF(309,"contextId"),e.k0s(),e.EFF(310," object, when the host component (e.g., request-scoped controller) is flagged as durable (you can learn how to mark providers as durable below). Also, in the above example, "),e.j41(311,"strong"),e.EFF(312,"no payload"),e.k0s(),e.EFF(313," would be registered (where payload = "),e.j41(314,"code"),e.EFF(315,"REQUEST"),e.k0s(),e.EFF(316,"/"),e.j41(317,"code"),e.EFF(318,"CONTEXT"),e.k0s(),e.EFF(319,' provider that represents the "root" - parent of the sub-tree).'),e.k0s(),e.j41(320,"p"),e.EFF(321,"If you want to register the payload for a durable tree, use the following construction instead:"),e.k0s(),e.j41(322,"pre")(323,"code",9),e.EFF(324,"\n// The return of `AggregateByTenantContextIdStrategy#attach` method:\nreturn {\n  resolve: (info: HostComponentInfo) =>\n    info.isTreeDurable ? tenantSubTreeId : contextId,\n  payload: { tenantId },\n}\n"),e.k0s()(),e.j41(325,"p"),e.EFF(326,"Now whenever you inject the "),e.j41(327,"code"),e.EFF(328,"REQUEST"),e.k0s(),e.EFF(329," provider (or "),e.j41(330,"code"),e.EFF(331,"CONTEXT"),e.k0s(),e.EFF(332," for GraphQL applications) using the "),e.j41(333,"code"),e.EFF(334,"@Inject(REQUEST)"),e.k0s(),e.EFF(335,"/"),e.j41(336,"code"),e.EFF(337,"@Inject(CONTEXT)"),e.k0s(),e.EFF(338,", the "),e.j41(339,"code"),e.EFF(340,"payload"),e.k0s(),e.EFF(341," object would be injected (consisting of a single property - "),e.j41(342,"code"),e.EFF(343,"tenantId"),e.k0s(),e.EFF(344," in this case)."),e.k0s(),e.j41(345,"p"),e.EFF(346,"Alright so with this strategy in place, you can register it somewhere in your code (as it applies globally anyway), so for example, you could place it in the "),e.j41(347,"code"),e.EFF(348,"main.ts"),e.k0s(),e.EFF(349," file:"),e.k0s(),e.j41(350,"pre")(351,"code",9),e.EFF(352,"\nContextIdFactory.apply(new AggregateByTenantContextIdStrategy());\n"),e.k0s()(),e.j41(353,"blockquote",7)(354,"strong"),e.EFF(355,"Hint"),e.k0s(),e.EFF(356," The "),e.j41(357,"code"),e.EFF(358,"ContextIdFactory"),e.k0s(),e.EFF(359," class is imported from the "),e.j41(360,"code"),e.EFF(361,"@nestjs/core"),e.k0s(),e.EFF(362," package.\n"),e.k0s(),e.j41(363,"p"),e.EFF(364,"As long as the registration occurs before any request hits your application, everything will work as intended."),e.k0s(),e.j41(365,"p"),e.EFF(366,"Lastly, to turn a regular provider into a durable provider, simply set the "),e.j41(367,"code"),e.EFF(368,"durable"),e.k0s(),e.EFF(369," flag to "),e.j41(370,"code"),e.EFF(371,"true"),e.k0s(),e.EFF(372," and change its scope to "),e.j41(373,"code"),e.EFF(374,"Scope.REQUEST"),e.k0s(),e.EFF(375," (not needed if the REQUEST scope is in the injection chain already):"),e.k0s(),e.j41(376,"pre")(377,"code",9),e.EFF(378,"\nimport { Injectable, Scope } from '@nestjs/common';\n\n@Injectable({ scope: Scope.REQUEST, durable: true })\nexport class CatsService {}\n"),e.k0s()(),e.j41(379,"p"),e.EFF(380,"Similarly, for "),e.j41(381,"a",10),e.EFF(382,"custom providers"),e.k0s(),e.EFF(383,", set the "),e.j41(384,"code"),e.EFF(385,"durable"),e.k0s(),e.EFF(386," property in the long-hand form for a provider registration:"),e.k0s(),e.j41(387,"pre")(388,"code",9),e.EFF(389,"\n{\n  provide: 'foobar',\n  useFactory: () => { ... },\n  scope: Scope.REQUEST,\n  durable: true,\n}\n"),e.k0s()()())},dependencies:[l.a,k.Q,p.Wk],encapsulation:2,changeDetection:0})}return t})(),data:{title:"Injection scopes"}},{path:"execution-context",component:(()=>{class t extends F.y{static \u0275fac=(()=>{let o;return function(n){return(o||(o=e.xGo(t)))(n||t)}})();static \u0275cmp=e.VBU({type:t,selectors:[["app-execution-context"]],features:[e.Vt3],decls:615,vars:72,consts:[["contentReference",""],["app12fdd33baada83e6dea51473bcfd9631358528dc",""],["app7f0eb934e8511c7756ec22915579c5473ac5788a",""],["app46787e32de4c5f351f949828c3fe9c8feacbcec2",""],["app70a8a68422b0d2b061a1ca2bf14741cb57f8c94d",""],["appf15daae860cab313a602f01a020a660ff810c9da",""],["app41d4dc1887cf66e41b00069220f72ff2350f6628",""],["app22541f91097f25a8fa87abf101b8c41ea9d40a48",""],["appc578aaf9e24aea3259349386c457e3d204ed432f",""],["app980ff6a71b02d205e12a80a2c9d57c159678c8f8",""],["appd38c49bd3a942b49c4e04cfa992850f07d1c8f80",""],[1,"content"],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/execution-context.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","execution-context"],["routerLink","/guards"],["routerLink","/exception-filters"],["routerLink","/interceptors"],["appAnchor","","id","argumentshost-class"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/exception-filters#arguments-host"],["routerLink","/graphql/quick-start"],["appAnchor","","id","current-application-context"],[1,"language-typescript"],[1,"info"],["appAnchor","","id","host-handler-arguments"],["appAnchor","","id","executioncontext-class"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/guards#execution-context"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/interceptors#execution-context"],["appAnchor","","id","reflection-and-metadata"],[1,"filename"],[1,"language-ts"],["appAnchor","","id","low-level-approach"]],template:function(s,n){if(1&s&&(e.j41(0,"div",11,0)(2,"div",12)(3,"a",13),e.nrm(4,"i",14),e.k0s()(),e.j41(5,"h3",15),e.EFF(6,"Execution context"),e.k0s(),e.j41(7,"p"),e.EFF(8,"Nest provides several utility classes that help make it easy to write applications that function across multiple application contexts (e.g., Nest HTTP server-based, microservices and WebSockets application contexts). These utilities provide information about the current execution context which can be used to build generic "),e.j41(9,"a",16),e.EFF(10,"guards"),e.k0s(),e.EFF(11,", "),e.j41(12,"a",17),e.EFF(13,"filters"),e.k0s(),e.EFF(14,", and "),e.j41(15,"a",18),e.EFF(16,"interceptors"),e.k0s(),e.EFF(17," that can work across a broad set of controllers, methods, and execution contexts."),e.k0s(),e.j41(18,"p"),e.EFF(19,"We cover two such classes in this chapter: "),e.j41(20,"code"),e.EFF(21,"ArgumentsHost"),e.k0s(),e.EFF(22," and "),e.j41(23,"code"),e.EFF(24,"ExecutionContext"),e.k0s(),e.EFF(25,"."),e.k0s(),e.j41(26,"h4",19)(27,"span"),e.EFF(28,"ArgumentsHost class"),e.k0s()(),e.j41(29,"p"),e.EFF(30,"The "),e.j41(31,"code"),e.EFF(32,"ArgumentsHost"),e.k0s(),e.EFF(33," class provides methods for retrieving the arguments being passed to a handler. It allows choosing the appropriate context (e.g., HTTP, RPC (microservice), or WebSockets) to retrieve the arguments from. The framework provides an instance of "),e.j41(34,"code"),e.EFF(35,"ArgumentsHost"),e.k0s(),e.EFF(36,", typically referenced as a "),e.j41(37,"code"),e.EFF(38,"host"),e.k0s(),e.EFF(39," parameter, in places where you may want to access it. For example, the "),e.j41(40,"code"),e.EFF(41,"catch()"),e.k0s(),e.EFF(42," method of an "),e.j41(43,"a",20),e.EFF(44,"exception filter"),e.k0s(),e.EFF(45," is called with an "),e.j41(46,"code"),e.EFF(47,"ArgumentsHost"),e.k0s(),e.EFF(48,"instance."),e.k0s(),e.j41(49,"p")(50,"code"),e.EFF(51,"ArgumentsHost"),e.k0s(),e.EFF(52," simply acts as an abstraction over a handler's arguments. For example, for HTTP server applications (when "),e.j41(53,"code"),e.EFF(54,"@nestjs/platform-express"),e.k0s(),e.EFF(55," is being used), the "),e.j41(56,"code"),e.EFF(57,"host"),e.k0s(),e.EFF(58," object encapsulates Express's "),e.j41(59,"code"),e.EFF(60,"[request, response, next]"),e.k0s(),e.EFF(61," array, where "),e.j41(62,"code"),e.EFF(63,"request"),e.k0s(),e.EFF(64," is the request object, "),e.j41(65,"code"),e.EFF(66,"response"),e.k0s(),e.EFF(67," is the response object, and "),e.j41(68,"code"),e.EFF(69,"next"),e.k0s(),e.EFF(70," is a function that controls the application's request-response cycle. On the other hand, for "),e.j41(71,"a",21),e.EFF(72,"GraphQL"),e.k0s(),e.EFF(73," applications, the "),e.j41(74,"code"),e.EFF(75,"host"),e.k0s(),e.EFF(76," object contains the "),e.j41(77,"code"),e.EFF(78,"[root, args, context, info]"),e.k0s(),e.EFF(79," array."),e.k0s(),e.j41(80,"h4",22)(81,"span"),e.EFF(82,"Current application context"),e.k0s()(),e.j41(83,"p"),e.EFF(84,"When building generic "),e.j41(85,"a",16),e.EFF(86,"guards"),e.k0s(),e.EFF(87,", "),e.j41(88,"a",17),e.EFF(89,"filters"),e.k0s(),e.EFF(90,", and "),e.j41(91,"a",18),e.EFF(92,"interceptors"),e.k0s(),e.EFF(93," which are meant to run across multiple application contexts, we need a way to determine the type of application that our method is currently running in. Do this with the "),e.j41(94,"code"),e.EFF(95,"getType()"),e.k0s(),e.EFF(96," method of "),e.j41(97,"code"),e.EFF(98,"ArgumentsHost"),e.k0s(),e.EFF(99,":"),e.k0s(),e.j41(100,"pre")(101,"code",23),e.EFF(102,"\nif (host.getType() === 'http') {\n  // do something that is only important in the context of regular HTTP requests (REST)\n} else if (host.getType() === 'rpc') {\n  // do something that is only important in the context of Microservice requests\n} else if (host.getType<GqlContextType>() === 'graphql') {\n  // do something that is only important in the context of GraphQL requests\n}\n"),e.k0s()(),e.j41(103,"blockquote",24)(104,"strong"),e.EFF(105,"Hint"),e.k0s(),e.EFF(106," The "),e.j41(107,"code"),e.EFF(108,"GqlContextType"),e.k0s(),e.EFF(109," is imported from the "),e.j41(110,"code"),e.EFF(111,"@nestjs/graphql"),e.k0s(),e.EFF(112," package.\n"),e.k0s(),e.j41(113,"p"),e.EFF(114,"With the application type available, we can write more generic components, as shown below."),e.k0s(),e.j41(115,"h4",25)(116,"span"),e.EFF(117,"Host handler arguments"),e.k0s()(),e.j41(118,"p"),e.EFF(119,"To retrieve the array of arguments being passed to the handler, one approach is to use the host object's "),e.j41(120,"code"),e.EFF(121,"getArgs()"),e.k0s(),e.EFF(122," method."),e.k0s(),e.j41(123,"pre")(124,"code",23),e.EFF(125,"\nconst [req, res, next] = host.getArgs();\n"),e.k0s()(),e.j41(126,"p"),e.EFF(127,"You can pluck a particular argument by index using the "),e.j41(128,"code"),e.EFF(129,"getArgByIndex()"),e.k0s(),e.EFF(130," method:"),e.k0s(),e.j41(131,"pre")(132,"code",23),e.EFF(133,"\nconst request = host.getArgByIndex(0);\nconst response = host.getArgByIndex(1);\n"),e.k0s()(),e.j41(134,"p"),e.EFF(135,"In these examples we retrieved the request and response objects by index, which is not typically recommended as it couples the application to a particular execution context. Instead, you can make your code more robust and reusable by using one of the "),e.j41(136,"code"),e.EFF(137,"host"),e.k0s(),e.EFF(138," object's utility methods to switch to the appropriate application context for your application. The context switch utility methods are shown below."),e.k0s(),e.j41(139,"pre")(140,"code",23),e.EFF(141,"\n/**\n * Switch context to RPC.\n */\nswitchToRpc(): RpcArgumentsHost;\n/**\n * Switch context to HTTP.\n */\nswitchToHttp(): HttpArgumentsHost;\n/**\n * Switch context to WebSockets.\n */\nswitchToWs(): WsArgumentsHost;\n"),e.k0s()(),e.j41(142,"p"),e.EFF(143,"Let's rewrite the previous example using the "),e.j41(144,"code"),e.EFF(145,"switchToHttp()"),e.k0s(),e.EFF(146," method. The "),e.j41(147,"code"),e.EFF(148,"host.switchToHttp()"),e.k0s(),e.EFF(149," helper call returns an "),e.j41(150,"code"),e.EFF(151,"HttpArgumentsHost"),e.k0s(),e.EFF(152," object that is appropriate for the HTTP application context. The "),e.j41(153,"code"),e.EFF(154,"HttpArgumentsHost"),e.k0s(),e.EFF(155," object has two useful methods we can use to extract the desired objects. We also use the Express type assertions in this case to return native Express typed objects:"),e.k0s(),e.j41(156,"pre")(157,"code",23),e.EFF(158,"\nconst ctx = host.switchToHttp();\nconst request = ctx.getRequest<Request>();\nconst response = ctx.getResponse<Response>();\n"),e.k0s()(),e.j41(159,"p"),e.EFF(160,"Similarly "),e.j41(161,"code"),e.EFF(162,"WsArgumentsHost"),e.k0s(),e.EFF(163," and "),e.j41(164,"code"),e.EFF(165,"RpcArgumentsHost"),e.k0s(),e.EFF(166," have methods to return appropriate objects in the microservices and WebSockets contexts. Here are the methods for "),e.j41(167,"code"),e.EFF(168,"WsArgumentsHost"),e.k0s(),e.EFF(169,":"),e.k0s(),e.j41(170,"pre")(171,"code",23),e.EFF(172,"\nexport interface WsArgumentsHost {\n  /**\n   * Returns the data object.\n   */\n  getData<T>(): T;\n  /**\n   * Returns the client object.\n   */\n  getClient<T>(): T;\n}\n"),e.k0s()(),e.j41(173,"p"),e.EFF(174,"Following are the methods for "),e.j41(175,"code"),e.EFF(176,"RpcArgumentsHost"),e.k0s(),e.EFF(177,":"),e.k0s(),e.j41(178,"pre")(179,"code",23),e.EFF(180,"\nexport interface RpcArgumentsHost {\n  /**\n   * Returns the data object.\n   */\n  getData<T>(): T;\n\n  /**\n   * Returns the context object.\n   */\n  getContext<T>(): T;\n}\n"),e.k0s()(),e.j41(181,"h4",26)(182,"span"),e.EFF(183,"ExecutionContext class"),e.k0s()(),e.j41(184,"p")(185,"code"),e.EFF(186,"ExecutionContext"),e.k0s(),e.EFF(187," extends "),e.j41(188,"code"),e.EFF(189,"ArgumentsHost"),e.k0s(),e.EFF(190,", providing additional details about the current execution process. Like "),e.j41(191,"code"),e.EFF(192,"ArgumentsHost"),e.k0s(),e.EFF(193,", Nest provides an instance of "),e.j41(194,"code"),e.EFF(195,"ExecutionContext"),e.k0s(),e.EFF(196," in places you may need it, such as in the "),e.j41(197,"code"),e.EFF(198,"canActivate()"),e.k0s(),e.EFF(199," method of a "),e.j41(200,"a",27),e.EFF(201,"guard"),e.k0s(),e.EFF(202," and the "),e.j41(203,"code"),e.EFF(204,"intercept()"),e.k0s(),e.EFF(205," method of an "),e.j41(206,"a",28),e.EFF(207,"interceptor"),e.k0s(),e.EFF(208,". It provides the following methods:"),e.k0s(),e.j41(209,"pre")(210,"code",23),e.EFF(211,"\nexport interface ExecutionContext extends ArgumentsHost {\n  /**\n   * Returns the type of the controller class which the current handler belongs to.\n   */\n  getClass<T>(): Type<T>;\n  /**\n   * Returns a reference to the handler (method) that will be invoked next in the\n   * request pipeline.\n   */\n  getHandler(): Function;\n}\n"),e.k0s()(),e.j41(212,"p"),e.EFF(213,"The "),e.j41(214,"code"),e.EFF(215,"getHandler()"),e.k0s(),e.EFF(216," method returns a reference to the handler about to be invoked. The "),e.j41(217,"code"),e.EFF(218,"getClass()"),e.k0s(),e.EFF(219," method returns the type of the "),e.j41(220,"code"),e.EFF(221,"Controller"),e.k0s(),e.EFF(222," class which this particular handler belongs to. For example, in an HTTP context, if the currently processed request is a "),e.j41(223,"code"),e.EFF(224,"POST"),e.k0s(),e.EFF(225," request, bound to the "),e.j41(226,"code"),e.EFF(227,"create()"),e.k0s(),e.EFF(228," method on the "),e.j41(229,"code"),e.EFF(230,"CatsController"),e.k0s(),e.EFF(231,", "),e.j41(232,"code"),e.EFF(233,"getHandler()"),e.k0s(),e.EFF(234," returns a reference to the "),e.j41(235,"code"),e.EFF(236,"create()"),e.k0s(),e.EFF(237," method and "),e.j41(238,"code"),e.EFF(239,"getClass()"),e.k0s(),e.EFF(240," returns the "),e.j41(241,"code"),e.EFF(242,"CatsController"),e.k0s(),e.j41(243,"strong"),e.EFF(244,"class"),e.k0s(),e.EFF(245," (not instance)."),e.k0s(),e.j41(246,"pre")(247,"code",23),e.EFF(248,'\nconst methodKey = ctx.getHandler().name; // "create"\nconst className = ctx.getClass().name; // "CatsController"\n'),e.k0s()(),e.j41(249,"p"),e.EFF(250,"The ability to access references to both the current class and handler method provides great flexibility. Most importantly, it gives us the opportunity to access the metadata set through either decorators created via "),e.j41(251,"code"),e.EFF(252,"Reflector#createDecorator"),e.k0s(),e.EFF(253," or the built-in "),e.j41(254,"code"),e.EFF(255,"@SetMetadata()"),e.k0s(),e.EFF(256," decorator from within guards or interceptors. We cover this use case below."),e.k0s(),e.j41(257,"p"),e.nrm(258,"app-banner-enterprise"),e.k0s(),e.j41(259,"h4",29)(260,"span"),e.EFF(261,"Reflection and metadata"),e.k0s()(),e.j41(262,"p"),e.EFF(263,"Nest provides the ability to attach "),e.j41(264,"strong"),e.EFF(265,"custom metadata"),e.k0s(),e.EFF(266," to route handlers through decorators created via "),e.j41(267,"code"),e.EFF(268,"Reflector#createDecorator"),e.k0s(),e.EFF(269," method, and the built-in "),e.j41(270,"code"),e.EFF(271,"@SetMetadata()"),e.k0s(),e.EFF(272," decorator. In this section, let's compare the two approaches and see how to access the metadata from within a guard or interceptor."),e.k0s(),e.j41(273,"p"),e.EFF(274,"To create strongly-typed decorators using "),e.j41(275,"code"),e.EFF(276,"Reflector#createDecorator"),e.k0s(),e.EFF(277,", we need to specify the type argument. For example, let's create a "),e.j41(278,"code"),e.EFF(279,"Roles"),e.k0s(),e.EFF(280," decorator that takes an array of strings as an argument."),e.k0s(),e.j41(281,"span",30),e.EFF(282),e.nI1(283,"extension"),e.nrm(284,"app-tabs",null,1),e.k0s(),e.j41(286,"pre")(287,"code",31),e.EFF(288,"\nimport { Reflector } from '@nestjs/core';\n\nexport const Roles = Reflector.createDecorator<string[]>();\n"),e.k0s()(),e.j41(289,"p"),e.EFF(290,"The "),e.j41(291,"code"),e.EFF(292,"Roles"),e.k0s(),e.EFF(293," decorator here is a function that takes a single argument of type "),e.j41(294,"code"),e.EFF(295,"string[]"),e.k0s(),e.EFF(296,"."),e.k0s(),e.j41(297,"p"),e.EFF(298,"Now, to use this decorator, we simply annotate the handler with it:"),e.k0s(),e.j41(299,"span",30),e.EFF(300),e.nI1(301,"extension"),e.nrm(302,"app-tabs",null,2),e.k0s(),e.j41(304,"pre")(305,"code",23),e.EFF(306,"\n@Post()\n@Roles(['admin'])\nasync create(@Body() createCatDto: CreateCatDto) {\n  this.catsService.create(createCatDto);\n}\n"),e.k0s()(),e.j41(307,"pre")(308,"code",23),e.EFF(309,"\n@Post()\n@Roles(['admin'])\n@Bind(Body())\nasync create(createCatDto) {\n  this.catsService.create(createCatDto);\n}\n"),e.k0s()(),e.j41(310,"p"),e.EFF(311,"Here we've attached the "),e.j41(312,"code"),e.EFF(313,"Roles"),e.k0s(),e.EFF(314," decorator metadata to the "),e.j41(315,"code"),e.EFF(316,"create()"),e.k0s(),e.EFF(317," method, indicating that only users with the "),e.j41(318,"code"),e.EFF(319,"admin"),e.k0s(),e.EFF(320," role should be allowed to access this route."),e.k0s(),e.j41(321,"p"),e.EFF(322,"To access the route's role(s) (custom metadata), we'll use the "),e.j41(323,"code"),e.EFF(324,"Reflector"),e.k0s(),e.EFF(325," helper class again. "),e.j41(326,"code"),e.EFF(327,"Reflector"),e.k0s(),e.EFF(328," can be injected into a class in the normal way:"),e.k0s(),e.j41(329,"span",30),e.EFF(330),e.nI1(331,"extension"),e.nrm(332,"app-tabs",null,3),e.k0s(),e.j41(334,"pre")(335,"code",23),e.EFF(336,"\n@Injectable()\nexport class RolesGuard {\n  constructor(private reflector: Reflector) {}\n}\n"),e.k0s()(),e.j41(337,"pre")(338,"code",23),e.EFF(339,"\n@Injectable()\n@Dependencies(Reflector)\nexport class CatsService {\n  constructor(reflector) {\n    this.reflector = reflector;\n  }\n}\n"),e.k0s()(),e.j41(340,"blockquote",24)(341,"strong"),e.EFF(342,"Hint"),e.k0s(),e.EFF(343," The "),e.j41(344,"code"),e.EFF(345,"Reflector"),e.k0s(),e.EFF(346," class is imported from the "),e.j41(347,"code"),e.EFF(348,"@nestjs/core"),e.k0s(),e.EFF(349," package.\n"),e.k0s(),e.j41(350,"p"),e.EFF(351,"Now, to read the handler metadata, use the "),e.j41(352,"code"),e.EFF(353,"get()"),e.k0s(),e.EFF(354," method:"),e.k0s(),e.j41(355,"pre")(356,"code",23),e.EFF(357,"\nconst roles = this.reflector.get(Roles, context.getHandler());\n"),e.k0s()(),e.j41(358,"p"),e.EFF(359,"The "),e.j41(360,"code"),e.EFF(361,"Reflector#get"),e.k0s(),e.EFF(362," method allows us to easily access the metadata by passing in two arguments: a decorator reference and a "),e.j41(363,"strong"),e.EFF(364,"context"),e.k0s(),e.EFF(365," (decorator target) to retrieve the metadata from. In this example, the specified "),e.j41(366,"strong"),e.EFF(367,"decorator"),e.k0s(),e.EFF(368," is "),e.j41(369,"code"),e.EFF(370,"Roles"),e.k0s(),e.EFF(371," (refer back to the "),e.j41(372,"code"),e.EFF(373,"roles.decorator.ts"),e.k0s(),e.EFF(374," file above). The context is provided by the call to "),e.j41(375,"code"),e.EFF(376,"context.getHandler()"),e.k0s(),e.EFF(377,", which results in extracting the metadata for the currently processed route handler. Remember, "),e.j41(378,"code"),e.EFF(379,"getHandler()"),e.k0s(),e.EFF(380," gives us a "),e.j41(381,"strong"),e.EFF(382,"reference"),e.k0s(),e.EFF(383," to the route handler function."),e.k0s(),e.j41(384,"p"),e.EFF(385,"Alternatively, we may organize our controller by applying metadata at the controller level, applying to all routes in the controller class."),e.k0s(),e.j41(386,"span",30),e.EFF(387),e.nI1(388,"extension"),e.nrm(389,"app-tabs",null,4),e.k0s(),e.j41(391,"pre")(392,"code",23),e.EFF(393,"\n@Roles(['admin'])\n@Controller('cats')\nexport class CatsController {}\n"),e.k0s()(),e.j41(394,"pre")(395,"code",23),e.EFF(396,"\n@Roles(['admin'])\n@Controller('cats')\nexport class CatsController {}\n"),e.k0s()(),e.j41(397,"p"),e.EFF(398,"In this case, to extract controller metadata, we pass "),e.j41(399,"code"),e.EFF(400,"context.getClass()"),e.k0s(),e.EFF(401," as the second argument (to provide the controller class as the context for metadata extraction) instead of "),e.j41(402,"code"),e.EFF(403,"context.getHandler()"),e.k0s(),e.EFF(404,":"),e.k0s(),e.j41(405,"span",30),e.EFF(406),e.nI1(407,"extension"),e.nrm(408,"app-tabs",null,5),e.k0s(),e.j41(410,"pre")(411,"code",23),e.EFF(412,"\nconst roles = this.reflector.get(Roles, context.getClass());\n"),e.k0s()(),e.j41(413,"p"),e.EFF(414,"Given the ability to provide metadata at multiple levels, you may need to extract and merge metadata from several contexts. The "),e.j41(415,"code"),e.EFF(416,"Reflector"),e.k0s(),e.EFF(417," class provides two utility methods used to help with this. These methods extract "),e.j41(418,"strong"),e.EFF(419,"both"),e.k0s(),e.EFF(420," controller and method metadata at once, and combine them in different ways."),e.k0s(),e.j41(421,"p"),e.EFF(422,"Consider the following scenario, where you've supplied "),e.j41(423,"code"),e.EFF(424,"Roles"),e.k0s(),e.EFF(425," metadata at both levels."),e.k0s(),e.j41(426,"span",30),e.EFF(427),e.nI1(428,"extension"),e.nrm(429,"app-tabs",null,6),e.k0s(),e.j41(431,"pre")(432,"code",23),e.EFF(433,"\n@Roles(['user'])\n@Controller('cats')\nexport class CatsController {\n  @Post()\n  @Roles(['admin'])\n  async create(@Body() createCatDto: CreateCatDto) {\n    this.catsService.create(createCatDto);\n  }\n}\n"),e.k0s()(),e.j41(434,"pre")(435,"code",23),e.EFF(436,"\n@Roles(['user'])\n@Controller('cats')\nexport class CatsController {}\n  @Post()\n  @Roles(['admin'])\n  @Bind(Body())\n  async create(createCatDto) {\n    this.catsService.create(createCatDto);\n  }\n}\n"),e.k0s()(),e.j41(437,"p"),e.EFF(438,"If your intent is to specify "),e.j41(439,"code"),e.EFF(440,"'user'"),e.k0s(),e.EFF(441," as the default role, and override it selectively for certain methods, you would probably use the "),e.j41(442,"code"),e.EFF(443,"getAllAndOverride()"),e.k0s(),e.EFF(444," method."),e.k0s(),e.j41(445,"pre")(446,"code",23),e.EFF(447,"\nconst roles = this.reflector.getAllAndOverride(Roles, [context.getHandler(), context.getClass()]);\n"),e.k0s()(),e.j41(448,"p"),e.EFF(449,"A guard with this code, running in the context of the "),e.j41(450,"code"),e.EFF(451,"create()"),e.k0s(),e.EFF(452," method, with the above metadata, would result in "),e.j41(453,"code"),e.EFF(454,"roles"),e.k0s(),e.EFF(455," containing "),e.j41(456,"code"),e.EFF(457,"['admin']"),e.k0s(),e.EFF(458,"."),e.k0s(),e.j41(459,"p"),e.EFF(460,"To get metadata for both and merge it (this method merges both arrays and objects), use the "),e.j41(461,"code"),e.EFF(462,"getAllAndMerge()"),e.k0s(),e.EFF(463," method:"),e.k0s(),e.j41(464,"pre")(465,"code",23),e.EFF(466,"\nconst roles = this.reflector.getAllAndMerge(Roles, [context.getHandler(), context.getClass()]);\n"),e.k0s()(),e.j41(467,"p"),e.EFF(468,"This would result in "),e.j41(469,"code"),e.EFF(470,"roles"),e.k0s(),e.EFF(471," containing "),e.j41(472,"code"),e.EFF(473,"['user', 'admin']"),e.k0s(),e.EFF(474,"."),e.k0s(),e.j41(475,"p"),e.EFF(476,"For both of these merge methods, you pass the metadata key as the first argument, and an array of metadata target contexts (i.e., calls to the "),e.j41(477,"code"),e.EFF(478,"getHandler()"),e.k0s(),e.EFF(479," and/or "),e.j41(480,"code"),e.EFF(481,"getClass()"),e.k0s(),e.EFF(482," methods) as the second argument."),e.k0s(),e.j41(483,"h4",32)(484,"span"),e.EFF(485,"Low-level approach"),e.k0s()(),e.j41(486,"p"),e.EFF(487,"As mentioned earlier, instead of using "),e.j41(488,"code"),e.EFF(489,"Reflector#createDecorator"),e.k0s(),e.EFF(490,", you can also use the built-in "),e.j41(491,"code"),e.EFF(492,"@SetMetadata()"),e.k0s(),e.EFF(493," decorator to attach metadata to a handler."),e.k0s(),e.j41(494,"span",30),e.EFF(495),e.nI1(496,"extension"),e.nrm(497,"app-tabs",null,7),e.k0s(),e.j41(499,"pre")(500,"code",23),e.EFF(501,"\n@Post()\n@SetMetadata('roles', ['admin'])\nasync create(@Body() createCatDto: CreateCatDto) {\n  this.catsService.create(createCatDto);\n}\n"),e.k0s()(),e.j41(502,"pre")(503,"code",23),e.EFF(504,"\n@Post()\n@SetMetadata('roles', ['admin'])\n@Bind(Body())\nasync create(createCatDto) {\n  this.catsService.create(createCatDto);\n}\n"),e.k0s()(),e.j41(505,"blockquote",24)(506,"strong"),e.EFF(507,"Hint"),e.k0s(),e.EFF(508," The "),e.j41(509,"code"),e.EFF(510,"@SetMetadata()"),e.k0s(),e.EFF(511," decorator is imported from the "),e.j41(512,"code"),e.EFF(513,"@nestjs/common"),e.k0s(),e.EFF(514," package.\n"),e.k0s(),e.j41(515,"p"),e.EFF(516,"With the construction above, we attached the "),e.j41(517,"code"),e.EFF(518,"roles"),e.k0s(),e.EFF(519," metadata ("),e.j41(520,"code"),e.EFF(521,"roles"),e.k0s(),e.EFF(522," is a metadata key and "),e.j41(523,"code"),e.EFF(524,"['admin']"),e.k0s(),e.EFF(525," is the associated value) to the "),e.j41(526,"code"),e.EFF(527,"create()"),e.k0s(),e.EFF(528," method. While this works, it's not good practice to use "),e.j41(529,"code"),e.EFF(530,"@SetMetadata()"),e.k0s(),e.EFF(531," directly in your routes. Instead, you can create your own decorators, as shown below:"),e.k0s(),e.j41(532,"span",30),e.EFF(533),e.nI1(534,"extension"),e.nrm(535,"app-tabs",null,8),e.k0s(),e.j41(537,"pre")(538,"code",23),e.EFF(539,"\nimport { SetMetadata } from '@nestjs/common';\n\nexport const Roles = (...roles: string[]) => SetMetadata('roles', roles);\n"),e.k0s()(),e.j41(540,"pre")(541,"code",23),e.EFF(542,"\nimport { SetMetadata } from '@nestjs/common';\n\nexport const Roles = (...roles) => SetMetadata('roles', roles);\n"),e.k0s()(),e.j41(543,"p"),e.EFF(544,"This approach is much cleaner and more readable, and somewhat resembles the "),e.j41(545,"code"),e.EFF(546,"Reflector#createDecorator"),e.k0s(),e.EFF(547," approach. The difference is that with "),e.j41(548,"code"),e.EFF(549,"@SetMetadata"),e.k0s(),e.EFF(550," you have more control over the metadata key and value, and also can create decorators that take more than one argument."),e.k0s(),e.j41(551,"p"),e.EFF(552,"Now that we have a custom "),e.j41(553,"code"),e.EFF(554,"@Roles()"),e.k0s(),e.EFF(555," decorator, we can use it to decorate the "),e.j41(556,"code"),e.EFF(557,"create()"),e.k0s(),e.EFF(558," method."),e.k0s(),e.j41(559,"span",30),e.EFF(560),e.nI1(561,"extension"),e.nrm(562,"app-tabs",null,9),e.k0s(),e.j41(564,"pre")(565,"code",23),e.EFF(566,"\n@Post()\n@Roles('admin')\nasync create(@Body() createCatDto: CreateCatDto) {\n  this.catsService.create(createCatDto);\n}\n"),e.k0s()(),e.j41(567,"pre")(568,"code",23),e.EFF(569,"\n@Post()\n@Roles('admin')\n@Bind(Body())\nasync create(createCatDto) {\n  this.catsService.create(createCatDto);\n}\n"),e.k0s()(),e.j41(570,"p"),e.EFF(571,"To access the route's role(s) (custom metadata), we'll use the "),e.j41(572,"code"),e.EFF(573,"Reflector"),e.k0s(),e.EFF(574," helper class again:"),e.k0s(),e.j41(575,"span",30),e.EFF(576),e.nI1(577,"extension"),e.nrm(578,"app-tabs",null,10),e.k0s(),e.j41(580,"pre")(581,"code",23),e.EFF(582,"\n@Injectable()\nexport class RolesGuard {\n  constructor(private reflector: Reflector) {}\n}\n"),e.k0s()(),e.j41(583,"pre")(584,"code",23),e.EFF(585,"\n@Injectable()\n@Dependencies(Reflector)\nexport class CatsService {\n  constructor(reflector) {\n    this.reflector = reflector;\n  }\n}\n"),e.k0s()(),e.j41(586,"blockquote",24)(587,"strong"),e.EFF(588,"Hint"),e.k0s(),e.EFF(589," The "),e.j41(590,"code"),e.EFF(591,"Reflector"),e.k0s(),e.EFF(592," class is imported from the "),e.j41(593,"code"),e.EFF(594,"@nestjs/core"),e.k0s(),e.EFF(595," package.\n"),e.k0s(),e.j41(596,"p"),e.EFF(597,"Now, to read the handler metadata, use the "),e.j41(598,"code"),e.EFF(599,"get()"),e.k0s(),e.EFF(600," method."),e.k0s(),e.j41(601,"pre")(602,"code",23),e.EFF(603,"\nconst roles = this.reflector.get<string[]>('roles', context.getHandler());\n"),e.k0s()(),e.j41(604,"p"),e.EFF(605,"Here instead of passing a decorator reference, we pass the metadata "),e.j41(606,"strong"),e.EFF(607,"key"),e.k0s(),e.EFF(608," as the first argument (which in our case is "),e.j41(609,"code"),e.EFF(610,"'roles'"),e.k0s(),e.EFF(611,"). Everything else remains the same as in the "),e.j41(612,"code"),e.EFF(613,"Reflector#createDecorator"),e.k0s(),e.EFF(614," example."),e.k0s()()),2&s){const a=e.sdS(285),r=e.sdS(303),i=e.sdS(333),d=e.sdS(390),m=e.sdS(409),u=e.sdS(430),h=e.sdS(498),j=e.sdS(536),g=e.sdS(563),v=e.sdS(579);e.R7$(282),e.SpI(" ",e.i5U(283,42,"roles.decorator",a.isJsActive),"\n"),e.R7$(18),e.SpI(" ",e.i5U(301,45,"cats.controller",r.isJsActive),"\n"),e.R7$(4),e.AVh("hide",r.isJsActive),e.R7$(3),e.AVh("hide",!r.isJsActive),e.R7$(23),e.SpI(" ",e.i5U(331,48,"roles.guard",i.isJsActive),"\n"),e.R7$(4),e.AVh("hide",i.isJsActive),e.R7$(3),e.AVh("hide",!i.isJsActive),e.R7$(50),e.SpI(" ",e.i5U(388,51,"cats.controller",d.isJsActive),"\n"),e.R7$(4),e.AVh("hide",d.isJsActive),e.R7$(3),e.AVh("hide",!d.isJsActive),e.R7$(12),e.SpI(" ",e.i5U(407,54,"roles.guard",m.isJsActive),"\n"),e.R7$(21),e.SpI(" ",e.i5U(428,57,"cats.controller",u.isJsActive),"\n"),e.R7$(4),e.AVh("hide",u.isJsActive),e.R7$(3),e.AVh("hide",!u.isJsActive),e.R7$(61),e.SpI(" ",e.i5U(496,60,"cats.controller",h.isJsActive),"\n"),e.R7$(4),e.AVh("hide",h.isJsActive),e.R7$(3),e.AVh("hide",!h.isJsActive),e.R7$(31),e.SpI(" ",e.i5U(534,63,"roles.decorator",j.isJsActive),"\n"),e.R7$(4),e.AVh("hide",j.isJsActive),e.R7$(3),e.AVh("hide",!j.isJsActive),e.R7$(20),e.SpI(" ",e.i5U(561,66,"cats.controller",g.isJsActive),"\n"),e.R7$(4),e.AVh("hide",g.isJsActive),e.R7$(3),e.AVh("hide",!g.isJsActive),e.R7$(9),e.SpI(" ",e.i5U(577,69,"roles.guard",v.isJsActive),"\n"),e.R7$(4),e.AVh("hide",v.isJsActive),e.R7$(3),e.AVh("hide",!v.isJsActive)}},dependencies:[E.O,l.a,R.d,p.Wk,f.M],encapsulation:2,changeDetection:0})}return t})(),data:{title:"Execution context"}},{path:"lifecycle-events",component:T,data:{title:"Lifecycle events"}},{path:"circular-dependency",component:S,data:{title:"Circular Dependency"}}];let q=(()=>{class t{static \u0275fac=function(s){return new(s||t)};static \u0275mod=e.$C({type:t});static \u0275inj=e.G2t({imports:[w.MD,C.G,p.iI.forChild(N)]})}return t})()}}]);